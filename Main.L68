00000000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/2/2016 1:56:01 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :Disassembler.Main
00000000                             3  * Written by :Blake Hashimoto
00000000                             4  * Date       :4/29/2016
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000                             7      
00000000                             8  *--------------------------------------------*
00000000                             9  * Program Input. Read user input start and   *
00000000                            10  * ending values                              *
00000000                            11  *--------------------------------------------*
00000000                            12  
00000000                            13  *----Display input message for mem start-----*
00000000                            14  INPUT_START
00000000                            15  *    BRA         TEST
Line 16 ERROR: Undefined symbol
00000000  43F9 004DBB8E             16      LEA         M_INPUT_START,A1      *load message
00000006  103C 000E                 17      MOVE.B      #14,D0          *display string
0000000A  4E4F                      18      TRAP        #15             *output string
0000000C                            19  *----Receive User Input ------
0000000C  227C 00000300             20      MOVE.L      #$0300,A1       *set address of register A1 for string
00000012  103C 0002                 21      MOVE.B      #2,D0           *input string into A1 Trap
00000016  4E4F                      22      TRAP        #15             *input string from user
00000018  6100 0040                 23      BSR         READ_CHAR       *check for valid input
Line 24 ERROR: Undefined symbol
0000001C  23C3 00544498             24      MOVE.L      D3,MEM_START    *put the starting address in memory
00000022  B87C 0000                 25      CMP         #0,D4           *check the result register (D4)
00000026  6700 0004                 26      BEQ         INPUT_END       *valid value. read the ending value
0000002A  60D4                      27      BRA         INPUT_START     *invalid value. try inputting start value again    
0000002C                            28      
0000002C                            29  *----Display input message for mem end-----*
0000002C                            30  INPUT_END
Line 31 ERROR: Undefined symbol
0000002C  43F9 004DBB8E             31      LEA         M_INPUT_END,A1  *load message
00000032  103C 000E                 32      MOVE.B      #14,D0          *display string
00000036  4E4F                      33      TRAP        #15             *output string
00000038                            34  *----Receive User Input ------*
00000038  227C 00000300             35      MOVE.L      #$0300,A1       *set address of register A1 for string
0000003E  103C 0002                 36      MOVE.B      #2,D0           *input string into A1 Trap
00000042  4E4F                      37      TRAP        #15             *input string from user
00000044  6100 0014                 38      BSR         READ_CHAR       *check for valid input
Line 39 ERROR: Undefined symbol
00000048  23C3 00544494             39      MOVE.L      D3,MEM_END      *put ending address into memory
0000004E  B87C 0000                 40      CMP         #0,D4           *check the result register (D4)
00000052  6700 00BE                 41      BEQ         READ_MEMORY     *valid value. read the ending value
00000056  60D4                      42      BRA         INPUT_END       *invalid value. try inputting start value again    
00000058                            43      
00000058                            44  GET_NEXT_INPUT
00000058  4E75                      45      RTS
0000005A                            46  
0000005A                            47  *----make sure that start value is valid----*
0000005A                            48  READ_CHAR                       *verify that string is valid (all hexadecimal digits)
0000005A  4243                      49      CLR         D3              *D3 will act as the total result
0000005C  2849                      50      MOVE.L      A1,A4           *the stop address
0000005E  143C 0006                 51      MOVE.B      #6,D2           *put 6 in D2
00000062  D8C2                      52      ADD.W       D2,A4           *A4 is now the stop address(A4)
00000064                            53      
00000064                            54  REMOVE_ZEROES
00000064  4281                      55      CLR.L       D1              *D1 will act as the temporary value
00000066  1211                      56      MOVE.B      (A1),D1         *read the byte from string
00000068  143C 0030                 57      MOVE.B      #$30,D2         *put ascii zero in D2
0000006C  B202                      58      CMP.B       D2,D1           *compare ascii zero and value of D1
0000006E  6700 0006                 59      BEQ         REMOVE_ZERO     *skip over that character   
00000072  6000 0008                 60      BRA         READ_CHAR_LOOP  *begin converting characters to numerical values
00000076                            61  REMOVE_ZERO
00000076  5289                      62      ADD.L       #1,A1           *increment string start address
00000078  528C                      63      ADD.L       #1,A4           *increment string end address
0000007A  60E8                      64      BRA         REMOVE_ZEROES   *loop back and keep removing zeroes
0000007C                            65  *----Convert String To Hex-----*
0000007C                            66  READ_CHAR_LOOP     
0000007C  4281                      67      CLR.L       D1              *D1 will act as the temporary value
0000007E  1211                      68      MOVE.B      (A1),D1         *read the byte from string
00000080                            69  *----check if the value is exaclty 00 (NULL)
00000080  B27C 0000                 70      CMP         #0,D1           *compare 00 (NULL) and the byte ascii value in D1
00000084  67D2                      71      BEQ         GET_NEXT_INPUT    *if you reached the end of the string, end loop
00000086                            72      
00000086  143C 0030                 73      MOVE.B      #$30,D2         *put ascii zero in D2
0000008A  B202                      74      CMP.B       D2,D1           *compare ascii zero and value of D1
0000008C  6D00 0036                 75      BLT         INVALID_CHAR_ERROR *branch on invalid (too small) ascii value   
00000090                            76  *------Result is greater than ascii 0--------*
00000090  143C 0066                 77      MOVE.B      #$66,D2         *put ascii f in D2
00000094  B202                      78      CMP.B       D2,D1           *compare ascii f and value of D1
00000096  6E2C                      79      BGT.B       INVALID_CHAR_ERROR *branch on invalid ascii value
00000098                            80  *------Result is between ascii 0 and f---------*
00000098  143C 0061                 81      MOVE.B      #$61,D2         *put ascii a in D2
0000009C  B202                      82      CMP.B       D2,D1           *compare ascii a and value of D1
0000009E  6C00 0046                 83      BGE         VALID_LETTER_LC *value is between a and f. Loop back.
000000A2                            84      
000000A2  143C 0039                 85      MOVE.B      #$39,D2         *put ascii 9 in D2
000000A6  B202                      86      CMP.B       D2,D1           *compare ascii 9 and value of D1
000000A8  6F00 002C                 87      BLE         VALID_NUMBER    *value between 0 and 9. Loop back.
000000AC                            88  
000000AC  143C 0041                 89      MOVE.B      #$41,D2         *put ascii A into D2
000000B0  B202                      90      CMP.B       D2,D1           *compare ascii A and value of D1
000000B2  6D00 0010                 91      BLT         INVALID_CHAR_ERROR    *value between 9 and A (Invalid)
000000B6                            92      
000000B6  143C 0046                 93      MOVE.B      #$46,D2         *put ascii F into D2
000000BA  B202                      94      CMP.B       D2,D1           *compare ascii F and value of D1
000000BC  6E00 0006                 95      BGT         INVALID_CHAR_ERROR    *value between F and a (Invalid)
000000C0                            96           
000000C0  6000 001C                 97      BRA         VALID_LETTER_UC *value is between A and F        
000000C4                            98  INVALID_CHAR_ERROR   
Line 99 ERROR: Undefined symbol
000000C4  43F9 004DBB8E             99      LEA         M_INVALID,A1    *load error message
000000CA  103C 000E                100      MOVE.B      #14,D0          *display string trap
000000CE  4E4F                     101      TRAP        #15             *output error message
000000D0  183C 0001                102      MOVE.B      #1,D4           *put invalid output in result register
000000D4  4E75                     103      RTS
000000D6                           104  VALID_NUMBER
000000D6  0401 0030                105      SUB.B       #$30,D1         *get actual value from ascii value
000000DA  6000 0012                106      BRA         VALID_CHAR      *read the next char in string
000000DE                           107  VALID_LETTER_UC
000000DE  0401 0037                108      SUB.B       #$37,D1         *get actual value from ascii value
000000E2  6000 000A                109      BRA         VALID_CHAR      *read the next char in string    
000000E6                           110  VALID_LETTER_LC
000000E6  0401 0057                111      SUB.B       #$57,D1         *get actual value from ascii value
000000EA  6000 0002                112      BRA         VALID_CHAR      *read the next char in string   
000000EE                           113  VALID_CHAR
000000EE  183C 0000                114      MOVE.B      #0,D4           *return valid value entry in D4    
000000F2  E98B                     115      LSL.L       #4,D3           *put hex digit in proper place
000000F4  D681                     116      ADD.L       D1,D3           *put new total in D3
000000F6  5289                     117      ADD.L       #1,A1           *increment address
000000F8  B8C9                     118      CMP         A1,A4           *if A1 > A4
000000FA  6E80                     119      BGT         READ_CHAR_LOOP  *begin converting to float    
000000FC  4E75                     120      RTS                         *loop back to INPUT_START || INPUT_END   
000000FE                           121     
000000FE                           122  TEST
Line 123 ERROR: Undefined symbol
000000FE  23FC 00003000 00544480   123      MOVE.L      #$3000,MEM_START
Line 124 ERROR: Undefined symbol
00000108  23FC 00003300 00544480   124      MOVE.L      #$3300,MEM_END
00000112                           125  READ_MEMORY   
Line 126 ERROR: Undefined symbol
00000112  2479 004DBB8E            126      MOVEA.L     MEM_START,A2    *A2 will be the starting/current address
Line 127 ERROR: Undefined symbol
00000118  2679 004DBB8E            127      MOVEA.L     MEM_END,A3      *A3 will act as the ending address
0000011E                           128      
0000011E                           129  VALIDATE_START_END
0000011E  220A                     130      MOVE.L      A2,D1           *copy start address into D1
00000120  240B                     131      MOVE.L      A3,D2           *copy end address into D2
00000122  B441                     132      CMP         D1,D2           *compare start and end values
00000124  6700 000C                133      BEQ         EQUAL_ERROR     *Start address is equal to end address
00000128  B441                     134      CMP         D1,D2           *compare start and end values
0000012A  6D00 0016                135      BLT         SWAP_VALUES     *Start address is larger than end address
0000012E  6000 002E                136      BRA         PRE_READ_MEMORY *begin reading memory
00000132                           137      
00000132                           138  EQUAL_ERROR
Line 139 ERROR: Undefined symbol
00000132  43F9 004DBB8E            139      LEA         M_EQUAL,A1      *load error message
00000138  103C 000E                140      MOVE.B      #14,D0          *display string trap
0000013C  4E4F                     141      TRAP        #15             *output error message
0000013E  6000 FEC0                142      BRA         INPUT_START     *restart program (request ui again)
00000142                           143      
00000142                           144  SWAP_VALUES
Line 145 ERROR: Undefined symbol
00000142  2239 004DBB8E            145      MOVE.L      MEM_START,D1    *put starting address in D1
Line 146 ERROR: Undefined symbol
00000148  2439 004DBB8E            146      MOVE.L      MEM_END,D2      *put ending address in D2
Line 147 ERROR: Undefined symbol
0000014E  23C2 00544498            147      MOVE.L      D2,MEM_START    *swap the two values in memory
Line 148 ERROR: Undefined symbol
00000154  23C1 00544480            148      MOVE.L      D1,MEM_END
0000015A  2442                     149      MOVEA.L     D2,A2           *A2 will be the starting/current address
0000015C  2641                     150      MOVEA.L     D1,A3           *A3 will act as the ending address
0000015E                           151  PRE_READ_MEMORY
0000015E  2C4A                     152      MOVE.L      A2,A6           *A6 will act as the current address for Data               
00000160                           153  READ_MEMORY_LOOP
Line 154 ERROR: Undefined symbol
00000160  2679 004DBB8E            154      MOVE.L      MEM_END,A3        *put ending address in A3
00000166  B6CA                     155      CMP         A2,A3             *compare the incrementing address and the end address
00000168  6D00 0020                156      BLT         CONTINUE_YN       *stop if the end address is reached
0000016C                           157      
0000016C  E05E                     158      ROR         #8,D6               *select correct byte
0000016E  BC3C 001E                159      CMP.B       #30,D6              *see if maximum lines printed
00000172  6C00 0048                160      BGE         PRESS_TO_CONTINUE
00000176  E15E                     161      ROL         #8,D6   
00000178                           162  READ_MEMORY_CONT                    *continue reading memory (if branched)  
00000178  101A                     163      MOVE.B      (A2)+,D0          *get the value from incrementing address 
0000017A  E148                     164      LSL.W       #8,D0             *make room for the next byte of A2
0000017C  1012                     165      MOVE.B      (A2),D0          *copy the rest of A2 to D0  
0000017E  538A                     166      SUB.L       #1, A2
Line 167 ERROR: Undefined symbol
00000180  47F9 004DBB8E            167      LEA         STRING_START,A3   *A3 will act as the string address  
Line 168 ERROR: Undefined symbol
00000186  6000 BA06                168      BRA         VERIFY_OPCODE
0000018A                           169      
0000018A                           170      
0000018A                           171          
0000018A                           172  *VERIFY_OPCODE
0000018A                           173  *-------------------------------------*
0000018A                           174  *BEGIN
0000018A                           175  *D0 will contain word with decodable opcode
0000018A                           176  *A2 will act as the current address
0000018A                           177  *if at any time the result is not an opcode,
0000018A                           178  *branch to "INVALID_OPCODE"
0000018A                           179  *-----Put opcode decode here----------*
0000018A                           180  *END
0000018A                           181  *A7 will be the address of the string that opcode is saved to
0000018A                           182  *A6 will be the start of the DATA address
0000018A                           183  *-------------------------------------*
0000018A                           184  
0000018A                           185  EFFECTIVE_ADDRESSING
0000018A                           186  *-------------------------------------*
0000018A                           187  *BEGIN
0000018A                           188  *D0 will contain word with decodable opcode
0000018A                           189  *A2 will act as the current address
0000018A                           190  *if at any time the result is not an opcode,
0000018A                           191  *branch to "INVALID_OPCODE"
0000018A                           192  *-----Put opcode decode here----------*
0000018A                           193  *END
0000018A                           194  *A7 will be the address of the string that opcode is saved to 
0000018A                           195  *A5 will be the start of the DATA address
0000018A                           196  *-------------------------------------*
0000018A                           197  
0000018A                           198  
0000018A                           199  CONTINUE_YN
Line 200 ERROR: Undefined symbol
0000018A  43F9 004DBB8E            200      LEA         M_FINISHED,A1       *print out finished reading address
00000190  103C 000E                201      MOVE.B      #14,D0
00000194  4E4F                     202      TRAP        #15
Line 203 ERROR: Undefined symbol
00000196  43F9 004DBB8E            203      LEA         M_CONTINUE,A1        *ask the user if they want to read again
0000019C  103C 000E                204      MOVE.B      #14,D0
000001A0  4E4F                     205      TRAP        #15
000001A2  103C 0005                206      MOVE.B      #5,D0               *get user input
000001A6  4E4F                     207      TRAP        #15
000001A8  B23C 0059                208      CMP.B       #89,D1              *compare user input and ascii 'Y'
000001AC  6700 00F8                209      BEQ         RESTART             *
000001B0  B23C 0079                210      CMP.B       #121,D1             *compare user input with ascii 'y'
000001B4  6700 00F0                211      BEQ         RESTART
Line 212 ERROR: Undefined symbol
000001B8  6000 B9D4                212      BRA         END
000001BC                           213      
000001BC                           214  PRESS_TO_CONTINUE
000001BC  1C3C 0000                215      MOVE.B      #00,D6              *reset counter
000001C0  E19E                     216      ROL.L       #8,D6               *put byte back in place
Line 217 ERROR: Undefined symbol
000001C2  43F9 004DBB8E            217      LEA         M_PRESS_CONT,A1     *load press key to continue messageu
000001C8  103C 000E                218      MOVE.B      #14,D0              *load into D0
000001CC  4E4F                     219      TRAP        #15                 *display message
000001CE  103C 0005                220      MOVE.B      #5,D0               *read single character from keyboard
000001D2  4E4F                     221      TRAP        #15    
000001D4  6100 0122                222      BSR         IM_NEW_LINE            *add new line
000001D8  609E                     223      BRA         READ_MEMORY_CONT    *continue reading loop
000001DA                           224      
000001DA                           225  INCREMENT_LINE
000001DA  E09E                     226      ROR.L       #8,D6               *select correct byte
000001DC  5206                     227      ADD.B       #1,D6               *increment counter
000001DE  E19E                     228      ROL.L       #8,D6               *put byte back in place
000001E0  4E75                     229      RTS 
000001E2                           230      
000001E2                           231  *word != opcode
000001E2                           232  INVALID_OPCODE
000001E2  BC3C 0008                233      CMP.B       #8,D6               *check the loop increment counter
000001E6  6D00 000A                234      BLT         INVALID_OPCODE_CONT *less than long length. continue       
000001EA  6100 000E                235      BSR         PRINT_DATA          *long amount of data. print it.
000001EE  6000 FF70                236      BRA         READ_MEMORY_LOOP    *read the next byte
000001F2                           237  INVALID_OPCODE_CONT  
000001F2  528A                     238      ADD.L       #1,A2               *increment current address  
000001F4  5206                     239      ADD.B       #1,D6               *increment counter
000001F6  6000 FF68                240      BRA         READ_MEMORY_LOOP    *data cap not reached. read next byte.    
000001FA                           241      
000001FA                           242  PRINT_DATA
000001FA  1C3C 0000                243      MOVE.B      #00,D6              *reset the increment counter
000001FE  6100 0012                244      BSR         PRINT_DATA_ADDRESS       *print the data address
00000202  6100 010E                245      BSR         TAB                 *insert a space
00000206  6100 0118                246      BSR         DATA                *print 'DATA'       
0000020A  6100 0028                247      BSR         PRINT_DATA_LOOP     *print the data
0000020E  61CA                     248      BSR         INCREMENT_LINE      *increment line counter (line was printed)
00000210  4E75                     249      RTS
00000212                           250  
00000212                           251  PRINT_DATA_ADDRESS
00000212  280E                     252      MOVE.L      A6,D4               *put the address in D4
00000214  4243                     253      CLR         D3                  *counter for long
00000216  6000 0008                254      BRA         PRINT_ADDRESS_LOOP
0000021A                           255  *print whatever's in D1
0000021A                           256  PRINT_ADDRESS
0000021A  280E                     257      MOVE.L      A6,D4               *put the address in D4
0000021C  4243                     258      CLR         D3                  *counter for long
0000021E  2C4A                     259      MOVE.L      A2, A6
00000220                           260      
00000220                           261  PRINT_ADDRESS_LOOP
00000220  B67C 0004                262      CMP         #4,D3               *if long reached
00000224  6C00 00B0                263      BGE         RETURN_TO_SUBROUTINE *exit loop
00000228  E19C                     264      ROL.L       #8,D4               *put ending byte at beginning
0000022A  1204                     265      MOVE.B      D4,D1               *put byte in D1 for printing
0000022C  6100 0022                266      BSR         OUTPUT_D1B          *print the first byte of D1
00000230  5203                     267      ADD.B       #1,D3               *increment D3 (loop counter)
00000232  60EC                     268      BRA         PRINT_ADDRESS_LOOP  *repeat loop         
00000234                           269           
00000234                           270  PRINT_DATA_LOOP
00000234  121E                     271      MOVE.B      (A6)+,D1            *get the data
00000236  1401                     272      MOVE.B      D1,D2               *copy the data to D2
00000238  BDCA                     273      CMP.L       A2,A6               *if current address reached
0000023A  6E00 000C                274      BGT         END_PRINT_DATA_LOOP *continue reading addresses 
0000023E                           275                                      *otherwise keep printing the data
0000023E  6100 0010                276      BSR         OUTPUT_D1B          *print byte in D1 in hex
00000242                           277      *---print a space----*
00000242  6100 00C2                278      BSR         IM_SPACE               *print a space                                
00000246  60EC                     279      BRA         PRINT_DATA_LOOP     *repeat loop
00000248                           280  
00000248                           281  END_PRINT_DATA_LOOP
00000248  2C4A                     282      MOVE.L      A2,A6               *set new address for data/opcode
0000024A  6100 00AC                283      BSR         IM_NEW_LINE            *end line
0000024E  4E75                     284      RTS                             *repeat loop   
00000250                           285   
00000250                           286  OUTPUT_D1B
00000250                           287      *print the left character
00000250  1401                     288      MOVE.B      D1,D2               *copy D1 to D2
00000252  E809                     289      LSR.B       #4,D1               *get rid of right nibble  
00000254  6100 0082                290      BSR         CONVERT_TO_ASCII    *convert value in D1, to ascii
00000258  6100 0096                291      BSR         OUTPUT_CHAR         *print the char in D1
0000025C                           292      *print the right character
0000025C  E90A                     293      LSL.B       #4,D2               *get rid of left nibble
0000025E  E80A                     294      LSR.B       #4,D2               *put right nibble in place
00000260  1202                     295      MOVE.B      D2,D1               *put right nibble in D1
00000262  6100 0074                296      BSR         CONVERT_TO_ASCII    *convert value in D1, to ascii
00000266  6100 0088                297      BSR         OUTPUT_CHAR         *print the char in D1
0000026A  4E75                     298      RTS
0000026C                           299  VALID_OPCODE
0000026C  BC3C 0000                300      CMP.B       #00,D6              *if leftover data not printed
00000270  6700 0004                301      BEQ         PRINT_OPCODE_EA     *print just the opcode
00000274  6184                     302      BSR         PRINT_DATA          *print unreadable data
00000276                           303                                      *and the opcode
00000276                           304  PRINT_OPCODE_EA    
00000276  548A                     305      ADD.L       #02,A2              *increment the current address because word is valid
00000278                           306  
00000278  1C3C 0000                307      MOVE.B      #00,D6              *reset the increment counter
0000027C  619C                     308      BSR         PRINT_ADDRESS       *print the data address
0000027E  6100 0092                309      BSR         TAB                 *insert a space
00000282  6100 000E                310      BSR         PRINT_OPCODE        *print out hte opcode and eA
00000286  6100 FF52                311      BSR         INCREMENT_LINE      *increment line counter (line was printed)
0000028A  6100 006C                312      BSR         IM_NEW_LINE
0000028E  6000 FED0                313      BRA         READ_MEMORY_LOOP    *read next byte.
00000292                           314      
00000292                           315  
00000292                           316  PRINT_OPCODE
Line 317 ERROR: Undefined symbol
00000292  43F9 004DBB8E            317      LEA         STRING_START,A1     *put the starting address of the string into A1
00000298  103C 000E                318      MOVE.B      #14,D0              *print null terminated string into A
0000029C  4E4F                     319      TRAP        #15                 *output to terminal
Line 320 ERROR: Undefined symbol
0000029E  47F9 004DBB8E            320      LEA         STRING_START,A3     *reset the current string pointer
000002A4  4E75                     321      RTS
000002A6                           322      
000002A6                           323  RESTART
Line 324 ERROR: Undefined symbol
000002A6  43F9 004DBB8E            324      LEA         M_NEW_LINE,A1
000002AC  103C 000E                325      MOVE.B      #14,D0
000002B0  4E4F                     326      TRAP        #15
000002B2                           327  *Clear all the data registers
000002B2  4280                     328      CLR.L       D0
000002B4  4281                     329      CLR.L       D1
000002B6  4282                     330      CLR.L       D2
000002B8  4283                     331      CLR.L       D3
000002BA  4284                     332      CLR.L       D4
000002BC  4285                     333      CLR.L       D5
000002BE  4286                     334      CLR.L       D6
000002C0  4287                     335      CLR.L       D7
000002C2                           336  *clear all the address registers
000002C2  2040                     337      MOVE.L      D0,A0
000002C4  2240                     338      MOVE.L      D0,A1
000002C6  2440                     339      MOVE.L      D0,A2
000002C8  2640                     340      MOVE.L      D0,A3
000002CA  2840                     341      MOVE.L      D0,A4
000002CC  2A40                     342      MOVE.L      D0,A5
000002CE  2C40                     343      MOVE.L      D0,A6
000002D0  2E40                     344      MOVE.L      D0,A7
000002D2  6000 FD2C                345      BRA         INPUT_START
000002D6                           346      
000002D6                           347  *-------------Return to subroutine----------------*    
000002D6                           348  RETURN_TO_SUBROUTINE
000002D6  4E75                     349      RTS
000002D8                           350    
000002D8                           351  *------Convert Number in D1 to ASCII------*
000002D8                           352  CONVERT_TO_ASCII
000002D8  B23C 0009                353      CMP.B       #9,D1           *compare value with 9
000002DC  6E00 000C                354      BGT         ALPH_CHAR       *convert to numeric ascii
000002E0  6000 0002                355      BRA         NUMERIC_CHAR    *convert to alphabetical ascii
000002E4                           356  NUMERIC_CHAR        
000002E4  0601 0030                357      ADD.B       #48,D1          *convert to ascii value
000002E8  4E75                     358      RTS                         *continue converting
000002EA                           359  ALPH_CHAR
000002EA  0601 0037                360      ADD.B       #55,D1          *convert to ascii value
000002EE  4E75                     361      RTS                         *continue converting            
000002F0                           362  OUTPUT_CHAR
000002F0  103C 0006                363      MOVE.B      #6,D0           *output whatever's in D1
000002F4  4E4F                     364      TRAP        #15
000002F6  4E75                     365      RTS
000002F8                           366  
000002F8                           367  
000002F8                           368  IM_NEW_LINE
Line 369 ERROR: Undefined symbol
000002F8  43F9 004DBB8E            369      LEA         M_NEW_LINE,A1      *load new line
000002FE  103C 000E                370      MOVE.B      #14,D0          *load message
00000302  4E4F                     371      TRAP        #15             *display message
00000304  4E75                     372      RTS
00000306                           373  IM_SPACE
00000306  123C 0020                374      MOVE.B      #32,D1
0000030A  103C 0006                375      MOVE.B      #6,D0
0000030E  4E4F                     376      TRAP        #15
00000310  4E75                     377      RTS
00000312                           378  TAB
Line 379 ERROR: Undefined symbol
00000312  43F9 004DBB8E            379      LEA         M_TAB,A1
00000318  103C 000E                380      MOVE.B      #14,D0
0000031C  4E4F                     381      TRAP        #15
0000031E  4E75                     382      RTS
00000320                           383  DATA
Line 384 ERROR: Undefined symbol
00000320  43F9 004DBB8E            384      LEA         M_DATA,A1
00000326  103C 000E                385      MOVE.B      #14,D0
0000032A  4E4F                     386      TRAP        #15
0000032C  4E75                     387      RTS
0000032E                           388      
0000032E                           389  
0000032E                           390  
0000032E                           391  *    SIMHALT             ; halt simulator
0000032E                           392  
0000032E                           393  *CR          EQU     $0D
0000032E                           394  *LF          EQU     $0A
0000032E                           395  *
0000032E                           396  *M_INPUT_START DC.B 'Please enter starting memory address in hexadecimal:',CR,LF,0
0000032E                           397  *M_INPUT_END   DC.B 'Please enter ending memory address in hexadecimal:',CR,LF,0
0000032E                           398  *M_INVALID     DC.B 'Invalid value. Please enter a valid value: ',CR,LF,0
0000032E                           399  *M_EQUAL       DC.B 'Equal values. No memory read. Please enter new values',CR,LF,0
0000032E                           400  *M_DATA        DC.B 'DATA    ',0
0000032E                           401  *M_TAB         DC.B '    ',0
0000032E                           402  *M_PRESS_CONT  DC.B 'Press any key to continue',0
0000032E                           403  *M_FINISHED    DC.B 'Finished Reading Memory',0
0000032E                           404  *M_CONTINUE    DC.B 'Would you like to read memory again? (Y/N)',0
0000032E                           405  *
0000032E                           406  *STRING_START    EQU     $0500
0000032E                           407  *DATA_START      EQU     $0400
0000032E                           408  *
0000032E                           409  *MEM_START       EQU     $0100
0000032E                           410  *MEM_END         EQU     $0200
0000032E                           411  *
0000032E                           412  *M_SPACE       DC.B  ' ',0
0000032E                           413  *M_NEW_LINE    DC.B  '',CR,LF,0
0000032E                           414  
0000032E                           415  
0000032E                           416  
0000032E                           417  
0000032E                           418  
0000032E                           419  
0000032E                           420  
0000032E                           421  
0000032E                           422  
0000032E                           423  
0000032E                           424  
0000032E                           425  
0000032E                           426  
0000032E                           427  
0000032E                           428  
0000032E                           429  
0000032E                           430  
0000032E                           431  
0000032E                           432  
0000032E                           433  
0000032E                           434  
0000032E                           435  
0000032E                           436  
0000032E                           437  
0000032E                           438  
0000032E                           439  
Line 440 WARNING: END directive missing, starting address not set

27 errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ALPH_CHAR           2EA
CONTINUE_YN         18A
CONVERT_TO_ASCII    2D8
DATA                320
EFFECTIVE_ADDRESSING  18A
END_PRINT_DATA_LOOP  248
EQUAL_ERROR         132
GET_NEXT_INPUT      58
IM_NEW_LINE         2F8
IM_SPACE            306
INCREMENT_LINE      1DA
INPUT_END           2C
INPUT_START         0
INVALID_CHAR_ERROR  C4
INVALID_OPCODE      1E2
INVALID_OPCODE_CONT  1F2
NUMERIC_CHAR        2E4
OUTPUT_CHAR         2F0
OUTPUT_D1B          250
PRESS_TO_CONTINUE   1BC
PRE_READ_MEMORY     15E
PRINT_ADDRESS       21A
PRINT_ADDRESS_LOOP  220
PRINT_DATA          1FA
PRINT_DATA_ADDRESS  212
PRINT_DATA_LOOP     234
PRINT_OPCODE        292
PRINT_OPCODE_EA     276
READ_CHAR           5A
READ_CHAR_LOOP      7C
READ_MEMORY         112
READ_MEMORY_CONT    178
READ_MEMORY_LOOP    160
REMOVE_ZERO         76
REMOVE_ZEROES       64
RESTART             2A6
RETURN_TO_SUBROUTINE  2D6
SWAP_VALUES         142
TAB                 312
TEST                FE
VALIDATE_START_END  11E
VALID_CHAR          EE
VALID_LETTER_LC     E6
VALID_LETTER_UC     DE
VALID_NUMBER        D6
VALID_OPCODE        26C
