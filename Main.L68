00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/31/2016 2:08:13 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :Disassembler.Main
00000000                             3  * Written by :Blake Hashimoto
00000000                             4  * Date       :4/29/2016
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      *TODO: CHANGE THIS VALUE TO RIGHT AFTER PROGRAM CODE
00000000  6000 0104                  9      BRA         TEST
00000004                            10  *----Display input message for mem start-----*
00000004                            11  INPUT_START
00000004  6000 0100                 12      BRA         TEST
00000008  43F9 00000282             13      LEA         M_INPUT_START,A1      *load message
0000000E  103C 000E                 14      MOVE.B      #14,D0          *display string
00000012  4E4F                      15      TRAP        #15             *output string
00000014                            16  *----Receive User Input ------
00000014  227C 00000300             17      MOVE.L      #$0300,A1       *set address of register A1 for string
0000001A  103C 0002                 18      MOVE.B      #2,D0           *input string into A1 Trap
0000001E  4E4F                      19      TRAP        #15             *input string from user
00000020  6100 0040                 20      BSR         READ_CHAR       *check for valid input
00000024  23C3 00000100             21      MOVE.L      D3,MEM_START    *put the starting address in memory
0000002A  B87C 0000                 22      CMP         #0,D4           *check the result register (D4)
0000002E  6700 0004                 23      BEQ         INPUT_END       *valid value. read the ending value
00000032  60D0                      24      BRA         INPUT_START     *invalid value. try inputting start value again    
00000034                            25      
00000034                            26  *----Display input message for mem end-----*
00000034                            27  INPUT_END
00000034  43F9 000002B9             28      LEA         M_INPUT_END,A1  *load message
0000003A  103C 000E                 29      MOVE.B      #14,D0          *display string
0000003E  4E4F                      30      TRAP        #15             *output string
00000040                            31  *----Receive User Input ------*
00000040  227C 00000300             32      MOVE.L      #$0300,A1       *set address of register A1 for string
00000046  103C 0002                 33      MOVE.B      #2,D0           *input string into A1 Trap
0000004A  4E4F                      34      TRAP        #15             *input string from user
0000004C  6100 0014                 35      BSR         READ_CHAR       *check for valid input
00000050  23C3 00000200             36      MOVE.L      D3,MEM_END      *put ending address into memory
00000056  B87C 0000                 37      CMP         #0,D4           *check the result register (D4)
0000005A  6700 00BE                 38      BEQ         READ_MEMORY     *valid value. read the ending value
0000005E  60D4                      39      BRA         INPUT_END       *invalid value. try inputting start value again    
00000060                            40      
00000060                            41  GET_NEXT_INPUT
00000060  4E75                      42      RTS
00000062                            43  
00000062                            44  *----make sure that start value is valid----*
00000062                            45  READ_CHAR                       *verify that string is valid (all hexadecimal digits)
00000062  4243                      46      CLR         D3              *D3 will act as the total result
00000064  2849                      47      MOVE.L      A1,A4           *the stop address
00000066  143C 0006                 48      MOVE.B      #6,D2           *put 6 in D2
0000006A  D8C2                      49      ADD.W       D2,A4           *A4 is now the stop address(A4)
0000006C                            50      
0000006C                            51  REMOVE_ZEROES
0000006C  4281                      52      CLR.L       D1              *D1 will act as the temporary value
0000006E  1211                      53      MOVE.B      (A1),D1         *read the byte from string
00000070  143C 0030                 54      MOVE.B      #$30,D2         *put ascii zero in D2
00000074  B202                      55      CMP.B       D2,D1           *compare ascii zero and value of D1
00000076  6700 0006                 56      BEQ         REMOVE_ZERO     *skip over that character   
0000007A  6000 0008                 57      BRA         READ_CHAR_LOOP  *begin converting characters to numerical values
0000007E                            58  REMOVE_ZERO
0000007E  5289                      59      ADD.L       #1,A1           *increment string start address
00000080  528C                      60      ADD.L       #1,A4           *increment string end address
00000082  60E8                      61      BRA         REMOVE_ZEROES   *loop back and keep removing zeroes
00000084                            62  *----Convert String To Hex-----*
00000084                            63  READ_CHAR_LOOP     
00000084  4281                      64      CLR.L       D1              *D1 will act as the temporary value
00000086  1211                      65      MOVE.B      (A1),D1         *read the byte from string
00000088                            66  *----check if the value is exaclty 00 (NULL)
00000088  B27C 0000                 67      CMP         #0,D1           *compare 00 (NULL) and the byte ascii value in D1
0000008C  67D2                      68      BEQ         GET_NEXT_INPUT    *if you reached the end of the string, end loop
0000008E                            69      
0000008E  143C 0030                 70      MOVE.B      #$30,D2         *put ascii zero in D2
00000092  B202                      71      CMP.B       D2,D1           *compare ascii zero and value of D1
00000094  6D00 0036                 72      BLT         INVALID_CHAR_ERROR *branch on invalid (too small) ascii value   
00000098                            73  *------Result is greater than ascii 0--------*
00000098  143C 0066                 74      MOVE.B      #$66,D2         *put ascii f in D2
0000009C  B202                      75      CMP.B       D2,D1           *compare ascii f and value of D1
0000009E  6E2C                      76      BGT.B       INVALID_CHAR_ERROR *branch on invalid ascii value
000000A0                            77  *------Result is between ascii 0 and f---------*
000000A0  143C 0061                 78      MOVE.B      #$61,D2         *put ascii a in D2
000000A4  B202                      79      CMP.B       D2,D1           *compare ascii a and value of D1
000000A6  6C00 0046                 80      BGE         VALID_LETTER_LC *value is between a and f. Loop back.
000000AA                            81      
000000AA  143C 0039                 82      MOVE.B      #$39,D2         *put ascii 9 in D2
000000AE  B202                      83      CMP.B       D2,D1           *compare ascii 9 and value of D1
000000B0  6F00 002C                 84      BLE         VALID_NUMBER    *value between 0 and 9. Loop back.
000000B4                            85  
000000B4  143C 0041                 86      MOVE.B      #$41,D2         *put ascii A into D2
000000B8  B202                      87      CMP.B       D2,D1           *compare ascii A and value of D1
000000BA  6D00 0010                 88      BLT         INVALID_CHAR_ERROR    *value between 9 and A (Invalid)
000000BE                            89      
000000BE  143C 0046                 90      MOVE.B      #$46,D2         *put ascii F into D2
000000C2  B202                      91      CMP.B       D2,D1           *compare ascii F and value of D1
000000C4  6E00 0006                 92      BGT         INVALID_CHAR_ERROR    *value between F and a (Invalid)
000000C8                            93           
000000C8  6000 001C                 94      BRA         VALID_LETTER_UC *value is between A and F        
000000CC                            95  INVALID_CHAR_ERROR   
000000CC  43F9 000002EE             96      LEA         M_INVALID,A1    *load error message
000000D2  103C 000E                 97      MOVE.B      #14,D0          *display string trap
000000D6  4E4F                      98      TRAP        #15             *output error message
000000D8  183C 0001                 99      MOVE.B      #1,D4           *put invalid output in result register
000000DC  4E75                     100      RTS
000000DE                           101  VALID_NUMBER
000000DE  0401 0030                102      SUB.B       #$30,D1         *get actual value from ascii value
000000E2  6000 0012                103      BRA         VALID_CHAR      *read the next char in string
000000E6                           104  VALID_LETTER_UC
000000E6  0401 0037                105      SUB.B       #$37,D1         *get actual value from ascii value
000000EA  6000 000A                106      BRA         VALID_CHAR      *read the next char in string    
000000EE                           107  VALID_LETTER_LC
000000EE  0401 0057                108      SUB.B       #$57,D1         *get actual value from ascii value
000000F2  6000 0002                109      BRA         VALID_CHAR      *read the next char in string   
000000F6                           110  VALID_CHAR
000000F6  183C 0000                111      MOVE.B      #0,D4           *return valid value entry in D4    
000000FA  E98B                     112      LSL.L       #4,D3           *put hex digit in proper place
000000FC  D681                     113      ADD.L       D1,D3           *put new total in D3
000000FE  5289                     114      ADD.L       #1,A1           *increment address
00000100  B8C9                     115      CMP         A1,A4           *if A1 > A4
00000102  6E80                     116      BGT         READ_CHAR_LOOP  *begin converting to float    
00000104  4E75                     117      RTS                         *loop back to INPUT_START || INPUT_END   
00000106                           118     
00000106                           119  TEST
00000106  23FC 00001000 00000100   120      MOVE.L      #$1000,MEM_START
00000110  23FC 00001300 00000200   121      MOVE.L      #$1300,MEM_END
0000011A                           122  READ_MEMORY   
0000011A  2479 00000100            123      MOVEA.L     MEM_START,A2    *A2 will be the starting/current address
00000120  2679 00000200            124      MOVEA.L     MEM_END,A3      *A3 will act as the ending address
00000126                           125      
00000126                           126  VALIDATE_START_END
00000126  220A                     127      MOVE.L      A2,D1           *copy start address into D1
00000128  240B                     128      MOVE.L      A3,D2           *copy end address into D2
0000012A  B441                     129      CMP         D1,D2           *compare start and end values
0000012C  6700 000A                130      BEQ         EQUAL_ERROR     *Start address is equal to end address
00000130  6D00 0016                131      BLT         SWAP_VALUES     *Start address is larger than end address
00000134  6000 002E                132      BRA         PRE_READ_MEMORY *begin reading memory
00000138                           133      
00000138                           134  EQUAL_ERROR
00000138  43F9 0000031C            135      LEA         M_EQUAL,A1      *load error message
0000013E  103C 000E                136      MOVE.B      #14,D0          *display string trap
00000142  4E4F                     137      TRAP        #15             *output error message
00000144  6000 FEBE                138      BRA         INPUT_START     *restart program (request ui again)
00000148                           139      
00000148                           140  SWAP_VALUES
00000148  2239 00000100            141      MOVE.L      MEM_START,D1    *put starting address in D1
0000014E  2439 00000200            142      MOVE.L      MEM_END,D2      *put ending address in D2
00000154  23C2 00000100            143      MOVE.L      D2,MEM_START    *swap the two values in memory
0000015A  23C1 00000200            144      MOVE.L      D1,MEM_END
00000160  2442                     145      MOVEA.L     D2,A2           *A2 will be the starting/current address
00000162  2641                     146      MOVEA.L     D1,A3           *A3 will act as the ending address
00000164                           147  PRE_READ_MEMORY
00000164  2C4A                     148      MOVE.L      A2,A6           *A6 will act as the current address for Data               
00000166                           149  READ_MEMORY_LOOP
00000166  2679 00000200            150      MOVE.L      MEM_END,A3        *put ending address in A3
0000016C  B6CA                     151      CMP         A2,A3             *compare the incrementing address and the end address
0000016E  6700 010E                152      BEQ         END               *stop if the end address is reached
00000172                           153      
00000172  E05E                     154      ROR         #8,D6               *select correct byte
00000174  BC3C 003C                155      CMP.B       #60,D6              *see if maximum lines printed
00000178  6C00 000E                156      BGE         PRESS_TO_CONTINUE
0000017C  E15E                     157      ROL         #8,D6
0000017E                           158  
0000017E                           159      
0000017E                           160  READ_MEMORY_CONT                    *continue reading memory (if branched)  
0000017E  101A                     161      MOVE.B      (A2)+,D0          *get the value from incrementing address 
00000180  E148                     162      LSL.W       #8,D0             *make room for the next byte of A2
00000182  1022                     163      MOVE.B      -(A2),D0          *copy the rest of A2 to D0    
Line 164 ERROR: Undefined symbol
00000184  6000 BA08                164      BRA         VERIFY_OPCODE
00000188                           165      
00000188                           166      
00000188                           167          
00000188                           168  *VERIFY_OPCODE
00000188                           169  *-------------------------------------*
00000188                           170  *BEGIN
00000188                           171  *D0 will contain word with decodable opcode
00000188                           172  *A2 will act as the current address
00000188                           173  *if at any time the result is not an opcode,
00000188                           174  *branch to "INVALID_OPCODE"
00000188                           175  *-----Put opcode decode here----------*
00000188                           176  *END
00000188                           177  *A7 will be the address of the string that opcode is saved to
00000188                           178  *A6 will be the start of the DATA address
00000188                           179  *-------------------------------------*
00000188                           180  
00000188                           181  EFFECTIVE_ADDRESSING
00000188                           182  *-------------------------------------*
00000188                           183  *BEGIN
00000188                           184  *D0 will contain word with decodable opcode
00000188                           185  *A2 will act as the current address
00000188                           186  *if at any time the result is not an opcode,
00000188                           187  *branch to "INVALID_OPCODE"
00000188                           188  *-----Put opcode decode here----------*
00000188                           189  *END
00000188                           190  *A7 will be the address of the string that opcode is saved to 
00000188                           191  *A5 will be the start of the DATA address
00000188                           192  *-------------------------------------*
00000188                           193  
00000188                           194      
00000188                           195  PRESS_TO_CONTINUE
00000188  1C3C 0000                196      MOVE.B      #00,D6              *reset counter
0000018C  E19E                     197      ROL.L       #8,D6               *put byte back in place
0000018E  43F9 00000362            198      LEA         M_PRESS_CONT,A1     *load press key to continue messageu
00000194  103C 000E                199      MOVE.B      #14,D0              *load into D0
00000198  4E4F                     200      TRAP        #15                 *display message
0000019A  103C 0005                201      MOVE.B      #5,D0               *read single character from keyboard
0000019E  4E4F                     202      TRAP        #15    
000001A0  6100 00A6                203      BSR         IM_NEW_LINE            *add new line
000001A4  60D8                     204      BRA         READ_MEMORY_CONT    *continue reading loop
000001A6                           205      
000001A6                           206  INCREMENT_LINE
000001A6  E09E                     207      ROR.L       #8,D6               *select correct byte
000001A8  5206                     208      ADD.B       #1,D6               *increment counter
000001AA  E19E                     209      ROL.L       #8,D6               *put byte back in place
000001AC  4E75                     210      RTS 
000001AE                           211      
000001AE                           212  *word != opcode
000001AE                           213  INVALID_OPCODE
000001AE  BC3C 0008                214      CMP.B       #8,D6               *check the loop increment counter
000001B2  6C00 0008                215      BGE         PRINT_DATA          *long amount of data. print it.
000001B6  528A                     216      ADD.L       #1,A2               *increment current address  
000001B8  5206                     217      ADD.B       #1,D6               *increment counter
000001BA  60AA                     218      BRA         READ_MEMORY_LOOP    *data cap not reached. read next byte.    
000001BC                           219      
000001BC                           220  PRINT_DATA
000001BC  1C3C 0000                221      MOVE.B      #00,D6              *reset the increment counter
000001C0  6100 0010                222      BSR         PRINT_ADDRESS       *print the data address
000001C4  6100 009C                223      BSR         TAB                 *insert a space
000001C8  6100 00A6                224      BSR         DATA                *print 'DATA'   
000001CC  61D8                     225      BSR         INCREMENT_LINE      *increment line counter (line was printed)
000001CE  6000 001C                226      BRA         PRINT_DATA_LOOP     *print the data
000001D2                           227  *print whatever's in D1
000001D2                           228  PRINT_ADDRESS
000001D2  280E                     229      MOVE.L      A6,D4               *put the address in D4
000001D4  4243                     230      CLR         D3                  *counter for long
000001D6                           231      
000001D6                           232  PRINT_ADDRESS_LOOP
000001D6  B67C 0004                233      CMP         #4,D3               *if long reached
000001DA  6C00 000E                234      BGE         RETURN_TO_SUBROUTINE *exit loop
000001DE  E19C                     235      ROL.L       #8,D4               *put ending byte at beginning
000001E0  1204                     236      MOVE.B      D4,D1               *put byte in D1 for printing
000001E2  6100 0028                237      BSR         OUTPUT_D1B          *print the first byte of D1
000001E6  5203                     238      ADD.B       #1,D3               *increment D3 (loop counter)
000001E8  60EC                     239      BRA         PRINT_ADDRESS_LOOP  *repeat loop         
000001EA                           240           
000001EA                           241  RETURN_TO_SUBROUTINE
000001EA  4E75                     242      RTS
000001EC                           243  PRINT_DATA_LOOP
000001EC  121E                     244      MOVE.B      (A6)+,D1            *get the data
000001EE  1401                     245      MOVE.B      D1,D2               *copy the data to D2
000001F0  BDCA                     246      CMP.L       A2,A6               *if current address reached
000001F2  6E00 000C                247      BGT         END_PRINT_DATA_LOOP *continue reading addresses 
000001F6                           248                                      *otherwise keep printing the data
000001F6  6100 0014                249      BSR         OUTPUT_D1B          *print byte in D1 in hex
000001FA                           250      *---print a space----*
000001FA  6100 005A                251      BSR         IM_SPACE               *print a space                                
000001FE  60EC                     252      BRA         PRINT_DATA_LOOP     *repeat loop
00000200                           253  
00000200                           254  END_PRINT_DATA_LOOP
00000200  2C4A                     255      MOVE.L      A2,A6               *set new address for data/opcode
00000202  6100 0044                256      BSR         IM_NEW_LINE            *end line
00000206  619E                     257      BSR         INCREMENT_LINE      *increment line printing counter
00000208  6000 FF5C                258      BRA         READ_MEMORY_LOOP    *repeat loop   
0000020C                           259   
0000020C                           260  OUTPUT_D1B
0000020C                           261      *print the left character
0000020C  1401                     262      MOVE.B      D1,D2               *copy D1 to D2
0000020E  E809                     263      LSR.B       #4,D1               *get rid of right nibble  
00000210  6100 0016                264      BSR         CONVERT_TO_ASCII    *convert value in D1, to ascii
00000214  6100 002A                265      BSR         OUTPUT_CHAR         *print the char in D1
00000218                           266      *print the right character
00000218  E90A                     267      LSL.B       #4,D2               *get rid of left nibble
0000021A  E80A                     268      LSR.B       #4,D2               *put right nibble in place
0000021C  1202                     269      MOVE.B      D2,D1               *put right nibble in D1
0000021E  6100 0008                270      BSR         CONVERT_TO_ASCII    *convert value in D1, to ascii
00000222  6100 001C                271      BSR         OUTPUT_CHAR         *print the char in D1
00000226  4E75                     272      RTS
00000228                           273  VALID_OPCODE 
00000228                           274      
00000228                           275    
00000228                           276  *------Convert Number in D1 to ASCII------*
00000228                           277  CONVERT_TO_ASCII
00000228  B23C 0009                278      CMP.B       #9,D1           *compare value with 9
0000022C  6E00 000C                279      BGT         ALPH_CHAR       *convert to numeric ascii
00000230  6000 0002                280      BRA         NUMERIC_CHAR    *convert to alphabetical ascii
00000234                           281  NUMERIC_CHAR        
00000234  0601 0030                282      ADD.B       #48,D1          *convert to ascii value
00000238  4E75                     283      RTS                         *continue converting
0000023A                           284  ALPH_CHAR
0000023A  0601 0037                285      ADD.B       #55,D1          *convert to ascii value
0000023E  4E75                     286      RTS                         *continue converting            
00000240                           287  OUTPUT_CHAR
00000240  103C 0006                288      MOVE.B      #6,D0           *output whatever's in D1
00000244  4E4F                     289      TRAP        #15
00000246  4E75                     290      RTS
00000248                           291  
00000248                           292  IM_NEW_LINE
Line 293 ERROR: Undefined symbol
00000248  43F9 004DBB8E            293      LEA         M_SPACE,A1      *load new line
0000024E  103C 000E                294      MOVE.B      #14,D0          *load message
00000252  4E4F                     295      TRAP        #15             *display message
00000254  4E75                     296      RTS
00000256                           297  IM_SPACE
00000256  123C 0020                298      MOVE.B      #32,D1
0000025A  103C 0006                299      MOVE.B      #6,D0
0000025E  4E4F                     300      TRAP        #15
00000260  4E75                     301      RTS
00000262                           302  TAB
00000262  43F9 0000035D            303      LEA         M_TAB,A1
00000268  103C 000E                304      MOVE.B      #14,D0
0000026C  4E4F                     305      TRAP        #15
0000026E  4E75                     306      RTS
00000270                           307  DATA
00000270  43F9 00000354            308      LEA         M_DATA,A1
00000276  103C 000E                309      MOVE.B      #14,D0
0000027A  4E4F                     310      TRAP        #15
0000027C  4E75                     311      RTS
0000027E                           312      
0000027E                           313  END
0000027E                           314  
0000027E  FFFF FFFF                315      SIMHALT             ; halt simulator
00000282                           316  
00000282  =0000000D                317  CR          EQU     $0D
00000282  =0000000A                318  LF          EQU     $0A
00000282                           319  
00000282= 50 6C 65 61 73 65 ...    320  M_INPUT_START DC.B 'Please enter starting memory address in hexadecimal:',CR,LF,0
000002B9= 50 6C 65 61 73 65 ...    321  M_INPUT_END   DC.B 'Please enter ending memory address in hexadecimal:',CR,LF,0
000002EE= 49 6E 76 61 6C 69 ...    322  M_INVALID     DC.B 'Invalid value. Please enter a valid value: ',CR,LF,0
0000031C= 45 71 75 61 6C 20 ...    323  M_EQUAL       DC.B 'Equal values. No memory read. Please enter new values',CR,LF,0
00000354= 44 41 54 41 20 20 ...    324  M_DATA        DC.B 'DATA    ',0
0000035D= 20 20 20 20 00           325  M_TAB         DC.B '    ',0
00000362= 50 72 65 73 73 20 ...    326  M_PRESS_CONT  DC.B 'Press any key to continue',0
0000037C                           327  
0000037C  =00000500                328  STRING_START    EQU     $0500
0000037C  =00000400                329  DATA_START      EQU     $0400
0000037C                           330  
0000037C  =00000100                331  MEM_START       EQU     $0100
0000037C  =00000200                332  MEM_END         EQU     $0200
0000037C                           333  
0000037C                           334  
0000037C                           335  
0000037C                           336  
0000037C                           337  
0000037C                           338  
0000037C                           339  
0000037C                           340  
0000037C                           341  
0000037C                           342  
0000037C                           343  
0000037C                           344  
0000037C                           345  
Line 346 WARNING: END directive missing, starting address not set

2 errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ALPH_CHAR           23A
CONVERT_TO_ASCII    228
CR                  D
DATA                270
DATA_START          400
EFFECTIVE_ADDRESSING  188
END                 27E
END_PRINT_DATA_LOOP  200
EQUAL_ERROR         138
GET_NEXT_INPUT      60
IM_NEW_LINE         248
IM_SPACE            256
INCREMENT_LINE      1A6
INPUT_END           34
INPUT_START         4
INVALID_CHAR_ERROR  CC
INVALID_OPCODE      1AE
LF                  A
MEM_END             200
MEM_START           100
M_DATA              354
M_EQUAL             31C
M_INPUT_END         2B9
M_INPUT_START       282
M_INVALID           2EE
M_PRESS_CONT        362
M_TAB               35D
NUMERIC_CHAR        234
OUTPUT_CHAR         240
OUTPUT_D1B          20C
PRESS_TO_CONTINUE   188
PRE_READ_MEMORY     164
PRINT_ADDRESS       1D2
PRINT_ADDRESS_LOOP  1D6
PRINT_DATA          1BC
PRINT_DATA_LOOP     1EC
READ_CHAR           62
READ_CHAR_LOOP      84
READ_MEMORY         11A
READ_MEMORY_CONT    17E
READ_MEMORY_LOOP    166
REMOVE_ZERO         7E
REMOVE_ZEROES       6C
RETURN_TO_SUBROUTINE  1EA
STRING_START        500
SWAP_VALUES         148
TAB                 262
TEST                106
VALIDATE_START_END  126
VALID_CHAR          F6
VALID_LETTER_LC     EE
VALID_LETTER_UC     E6
VALID_NUMBER        DE
VALID_OPCODE        228
