00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/1/2016 8:33:21 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :
00000000                             3  * Written by :
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  MAIN:                  ; first instruction of program
00001000  6000 FD03                  9      BRA             3333
00001004  6000 0006                 10      BRA             INPUT_START
00001008                            11      
00001008                            12      INCLUDE         'Main.X68'
00001008                            13  
00001008                            14      *TODO: CHANGE THIS VALUE TO RIGHT AFTER PROGRAM CODE   
00001008  6000 0104                 15      BRA         TEST
0000100C                            16      
0000100C                            17  
0000100C                            18  INPUT_START
0000100C  6000 0100                 19      BRA         TEST
00001010  43F9 00001F76             20      LEA         M_INPUT_START,A1      *load message
00001016  103C 000E                 21      MOVE.B      #14,D0          *display string
0000101A  4E4F                      22      TRAP        #15             *output string
0000101C  227C 00000300             23      MOVE.L      #$0300,A1       *set address of register A1 for string
00001022  103C 0002                 24      MOVE.B      #2,D0           *input string into A1 Trap
00001026  4E4F                      25      TRAP        #15             *input string from user
00001028  6100 0040                 26      BSR         READ_CHAR       *check for valid input
0000102C  23C3 00000100             27      MOVE.L      D3,MEM_START    *put the starting address in memory
00001032  B87C 0000                 28      CMP         #0,D4           *check the result register (D4)
00001036  6700 0004                 29      BEQ         INPUT_END       *valid value. read the ending value
0000103A  60D0                      30      BRA         INPUT_START     *invalid value. try inputting start value again    
0000103C                            31      
0000103C                            32  INPUT_END
0000103C  43F9 00001FAD             33      LEA         M_INPUT_END,A1  *load message
00001042  103C 000E                 34      MOVE.B      #14,D0          *display string
00001046  4E4F                      35      TRAP        #15             *output string
00001048  227C 00000300             36      MOVE.L      #$0300,A1       *set address of register A1 for string
0000104E  103C 0002                 37      MOVE.B      #2,D0           *input string into A1 Trap
00001052  4E4F                      38      TRAP        #15             *input string from user
00001054  6100 0014                 39      BSR         READ_CHAR       *check for valid input
00001058  23C3 00000200             40      MOVE.L      D3,MEM_END      *put ending address into memory
0000105E  B87C 0000                 41      CMP         #0,D4           *check the result register (D4)
00001062  6700 00BE                 42      BEQ         READ_MEMORY     *valid value. read the ending value
00001066  60D4                      43      BRA         INPUT_END       *invalid value. try inputting start value again    
00001068                            44      
00001068                            45  GET_NEXT_INPUT
00001068  4E75                      46      RTS
0000106A                            47  
0000106A                            48  READ_CHAR                       *verify that string is valid (all hexadecimal digits)
0000106A  4243                      49      CLR         D3              *D3 will act as the total result
0000106C  2849                      50      MOVE.L      A1,A4           *the stop address
0000106E  143C 0006                 51      MOVE.B      #6,D2           *put 6 in D2
00001072  D8C2                      52      ADD.W       D2,A4           *A4 is now the stop address(A4)
00001074                            53      
00001074                            54  REMOVE_ZEROES
00001074  4281                      55      CLR.L       D1              *D1 will act as the temporary value
00001076  1211                      56      MOVE.B      (A1),D1         *read the byte from string
00001078  143C 0030                 57      MOVE.B      #$30,D2         *put ascii zero in D2
0000107C  B202                      58      CMP.B       D2,D1           *compare ascii zero and value of D1
0000107E  6700 0006                 59      BEQ         REMOVE_ZERO     *skip over that character   
00001082  6000 0008                 60      BRA         READ_CHAR_LOOP  *begin converting characters to numerical values
00001086                            61  REMOVE_ZERO
00001086  5289                      62      ADD.L       #1,A1           *increment string start address
00001088  528C                      63      ADD.L       #1,A4           *increment string end address
0000108A  60E8                      64      BRA         REMOVE_ZEROES   *loop back and keep removing zeroes
0000108C                            65  READ_CHAR_LOOP     
0000108C  4281                      66      CLR.L       D1              *D1 will act as the temporary value
0000108E  1211                      67      MOVE.B      (A1),D1         *read the byte from string
00001090  B27C 0000                 68      CMP         #0,D1           *compare 00 (NULL) and the byte ascii value in D1
00001094  67D2                      69      BEQ         GET_NEXT_INPUT    *if you reached the end of the string, end loop
00001096                            70      
00001096  143C 0030                 71      MOVE.B      #$30,D2         *put ascii zero in D2
0000109A  B202                      72      CMP.B       D2,D1           *compare ascii zero and value of D1
0000109C  6D00 0036                 73      BLT         INVALID_CHAR_ERROR *branch on invalid (too small) ascii value   
000010A0  143C 0066                 74      MOVE.B      #$66,D2         *put ascii f in D2
000010A4  B202                      75      CMP.B       D2,D1           *compare ascii f and value of D1
000010A6  6E2C                      76      BGT.B       INVALID_CHAR_ERROR *branch on invalid ascii value
000010A8  143C 0061                 77      MOVE.B      #$61,D2         *put ascii a in D2
000010AC  B202                      78      CMP.B       D2,D1           *compare ascii a and value of D1
000010AE  6C00 0046                 79      BGE         VALID_LETTER_LC *value is between a and f. Loop back.
000010B2                            80      
000010B2  143C 0039                 81      MOVE.B      #$39,D2         *put ascii 9 in D2
000010B6  B202                      82      CMP.B       D2,D1           *compare ascii 9 and value of D1
000010B8  6F00 002C                 83      BLE         VALID_NUMBER    *value between 0 and 9. Loop back.
000010BC                            84  
000010BC  143C 0041                 85      MOVE.B      #$41,D2         *put ascii A into D2
000010C0  B202                      86      CMP.B       D2,D1           *compare ascii A and value of D1
000010C2  6D00 0010                 87      BLT         INVALID_CHAR_ERROR    *value between 9 and A (Invalid)
000010C6                            88      
000010C6  143C 0046                 89      MOVE.B      #$46,D2         *put ascii F into D2
000010CA  B202                      90      CMP.B       D2,D1           *compare ascii F and value of D1
000010CC  6E00 0006                 91      BGT         INVALID_CHAR_ERROR    *value between F and a (Invalid)
000010D0                            92           
000010D0  6000 001C                 93      BRA         VALID_LETTER_UC *value is between A and F        
000010D4                            94  INVALID_CHAR_ERROR   
000010D4  43F9 00001FE2             95      LEA         M_INVALID,A1    *load error message
000010DA  103C 000E                 96      MOVE.B      #14,D0          *display string trap
000010DE  4E4F                      97      TRAP        #15             *output error message
000010E0  183C 0001                 98      MOVE.B      #1,D4           *put invalid output in result register
000010E4  4E75                      99      RTS
000010E6                           100  VALID_NUMBER
000010E6  0401 0030                101      SUB.B       #$30,D1         *get actual value from ascii value
000010EA  6000 0012                102      BRA         VALID_CHAR      *read the next char in string
000010EE                           103  VALID_LETTER_UC
000010EE  0401 0037                104      SUB.B       #$37,D1         *get actual value from ascii value
000010F2  6000 000A                105      BRA         VALID_CHAR      *read the next char in string    
000010F6                           106  VALID_LETTER_LC
000010F6  0401 0057                107      SUB.B       #$57,D1         *get actual value from ascii value
000010FA  6000 0002                108      BRA         VALID_CHAR      *read the next char in string   
000010FE                           109  VALID_CHAR
000010FE  183C 0000                110      MOVE.B      #0,D4           *return valid value entry in D4    
00001102  E98B                     111      LSL.L       #4,D3           *put hex digit in proper place
00001104  D681                     112      ADD.L       D1,D3           *put new total in D3
00001106  5289                     113      ADD.L       #1,A1           *increment address
00001108  B8C9                     114      CMP         A1,A4           *if A1 > A4
0000110A  6E80                     115      BGT         READ_CHAR_LOOP  *begin converting to float    
0000110C  4E75                     116      RTS                         *loop back to INPUT_START || INPUT_END   
0000110E                           117     
0000110E                           118  TEST
0000110E  23FC 00001000 00000100   119      MOVE.L      #$1000,MEM_START
00001118  23FC 00001300 00000200   120      MOVE.L      #$1300,MEM_END
00001122                           121  READ_MEMORY   
00001122  2479 00000100            122      MOVEA.L     MEM_START,A2    *A2 will be the starting/current address
00001128  2679 00000200            123      MOVEA.L     MEM_END,A3      *A3 will act as the ending address
0000112E                           124      
0000112E                           125  VALIDATE_START_END
0000112E  220A                     126      MOVE.L      A2,D1           *copy start address into D1
00001130  240B                     127      MOVE.L      A3,D2           *copy end address into D2
00001132  B441                     128      CMP         D1,D2           *compare start and end values
00001134  6700 000A                129      BEQ         EQUAL_ERROR     *Start address is equal to end address
00001138  6D00 0016                130      BLT         SWAP_VALUES     *Start address is larger than end address
0000113C  6000 002E                131      BRA         PRE_READ_MEMORY *begin reading memory
00001140                           132      
00001140                           133  EQUAL_ERROR
00001140  43F9 00002010            134      LEA         M_EQUAL,A1      *load error message
00001146  103C 000E                135      MOVE.B      #14,D0          *display string trap
0000114A  4E4F                     136      TRAP        #15             *output error message
0000114C  6000 FEBE                137      BRA         INPUT_START     *restart program (request ui again)
00001150                           138      
00001150                           139  SWAP_VALUES
00001150  2239 00000100            140      MOVE.L      MEM_START,D1    *put starting address in D1
00001156  2439 00000200            141      MOVE.L      MEM_END,D2      *put ending address in D2
0000115C  23C2 00000100            142      MOVE.L      D2,MEM_START    *swap the two values in memory
00001162  23C1 00000200            143      MOVE.L      D1,MEM_END
00001168  2442                     144      MOVEA.L     D2,A2           *A2 will be the starting/current address
0000116A  2641                     145      MOVEA.L     D1,A3           *A3 will act as the ending address
0000116C                           146  PRE_READ_MEMORY
0000116C  2C4A                     147      MOVE.L      A2,A6           *A6 will act as the current address for Data               
0000116E                           148  READ_MEMORY_LOOP
0000116E  2679 00000200            149      MOVE.L      MEM_END,A3        *put ending address in A3
00001174  B6CA                     150      CMP         A2,A3             *compare the incrementing address and the end address
00001176  6700 014A                151      BEQ         END               *stop if the end address is reached
0000117A                           152      
0000117A  E05E                     153      ROR         #8,D6               *select correct byte
0000117C  BC3C 003C                154      CMP.B       #60,D6              *see if maximum lines printed
00001180  6C00 000E                155      BGE         PRESS_TO_CONTINUE
00001184  E15E                     156      ROL         #8,D6
00001186                           157  
00001186                           158      
00001186                           159  READ_MEMORY_CONT                    *continue reading memory (if branched)  
00001186  101A                     160      MOVE.B      (A2)+,D0          *get the value from incrementing address 
00001188  E148                     161      LSL.W       #8,D0             *make room for the next byte of A2
0000118A  1022                     162      MOVE.B      -(A2),D0          *copy the rest of A2 to D0    
0000118C  6000 0134                163      BRA         VERIFY_OPCODE
00001190                           164      
00001190                           165      
00001190                           166          
00001190                           167  
00001190                           168  EFFECTIVE_ADDRESSING
00001190                           169  
00001190                           170      
00001190                           171  PRESS_TO_CONTINUE
00001190  1C3C 0000                172      MOVE.B      #00,D6              *reset counter
00001194  E19E                     173      ROL.L       #8,D6               *put byte back in place
00001196  43F9 00002056            174      LEA         M_PRESS_CONT,A1     *load press key to continue messageu
0000119C  103C 000E                175      MOVE.B      #14,D0              *load into D0
000011A0  4E4F                     176      TRAP        #15                 *display message
000011A2  103C 0005                177      MOVE.B      #5,D0               *read single character from keyboard
000011A6  4E4F                     178      TRAP        #15    
000011A8  6100 00E2                179      BSR         IM_NEW_LINE            *add new line
000011AC  60D8                     180      BRA         READ_MEMORY_CONT    *continue reading loop
000011AE                           181      
000011AE                           182  INCREMENT_LINE
000011AE  E09E                     183      ROR.L       #8,D6               *select correct byte
000011B0  5206                     184      ADD.B       #1,D6               *increment counter
000011B2  E19E                     185      ROL.L       #8,D6               *put byte back in place
000011B4  4E75                     186      RTS 
000011B6                           187      
000011B6                           188  INVALID_OPCODE
000011B6  BC3C 0008                189      CMP.B       #8,D6               *check the loop increment counter
000011BA  6D00 0008                190      BLT         INVALID_OPCODE_CONT *less than long length. continue       
000011BE  6100 000A                191      BSR         PRINT_DATA          *long amount of data. print it.
000011C2  60AA                     192      BRA         READ_MEMORY_LOOP    *read the next byte
000011C4                           193  INVALID_OPCODE_CONT  
000011C4  528A                     194      ADD.L       #1,A2               *increment current address  
000011C6  5206                     195      ADD.B       #1,D6               *increment counter
000011C8  60A4                     196      BRA         READ_MEMORY_LOOP    *data cap not reached. read next byte.    
000011CA                           197      
000011CA                           198  PRINT_DATA
000011CA  1C3C 0000                199      MOVE.B      #00,D6              *reset the increment counter
000011CE  6100 0012                200      BSR         PRINT_ADDRESS       *print the data address
000011D2  6100 00D2                201      BSR         TAB                 *insert a space
000011D6  6100 00DC                202      BSR         DATA                *print 'DATA'   
000011DA  61D2                     203      BSR         INCREMENT_LINE      *increment line counter (line was printed)
000011DC  6100 001C                204      BSR         PRINT_DATA_LOOP     *print the data
000011E0  4E75                     205      RTS
000011E2                           206  PRINT_ADDRESS
000011E2  280E                     207      MOVE.L      A6,D4               *put the address in D4
000011E4  4243                     208      CLR         D3                  *counter for long
000011E6                           209      
000011E6                           210  PRINT_ADDRESS_LOOP
000011E6  B67C 0004                211      CMP         #4,D3               *if long reached
000011EA  6C00 007E                212      BGE         RETURN_TO_SUBROUTINE *exit loop
000011EE  E19C                     213      ROL.L       #8,D4               *put ending byte at beginning
000011F0  1204                     214      MOVE.B      D4,D1               *put byte in D1 for printing
000011F2  6100 0024                215      BSR         OUTPUT_D1B          *print the first byte of D1
000011F6  5203                     216      ADD.B       #1,D3               *increment D3 (loop counter)
000011F8  60EC                     217      BRA         PRINT_ADDRESS_LOOP  *repeat loop         
000011FA                           218           
000011FA                           219  PRINT_DATA_LOOP
000011FA  121E                     220      MOVE.B      (A6)+,D1            *get the data
000011FC  1401                     221      MOVE.B      D1,D2               *copy the data to D2
000011FE  BDCA                     222      CMP.L       A2,A6               *if current address reached
00001200  6E00 000C                223      BGT         END_PRINT_DATA_LOOP *continue reading addresses 
00001204                           224                                      *otherwise keep printing the data
00001204  6100 0012                225      BSR         OUTPUT_D1B          *print byte in D1 in hex
00001208                           226      *---print a space----*
00001208  6100 0090                227      BSR         IM_SPACE               *print a space                                
0000120C  60EC                     228      BRA         PRINT_DATA_LOOP     *repeat loop
0000120E                           229  
0000120E                           230  END_PRINT_DATA_LOOP
0000120E  2C4A                     231      MOVE.L      A2,A6               *set new address for data/opcode
00001210  6100 007A                232      BSR         IM_NEW_LINE            *end line
00001214  6198                     233      BSR         INCREMENT_LINE      *increment line printing counter
00001216  4E75                     234      RTS                             *repeat loop   
00001218                           235   
00001218                           236  OUTPUT_D1B
00001218                           237      *print the left character
00001218  1401                     238      MOVE.B      D1,D2               *copy D1 to D2
0000121A  E809                     239      LSR.B       #4,D1               *get rid of right nibble  
0000121C  6100 004E                240      BSR         CONVERT_TO_ASCII    *convert value in D1, to ascii
00001220  6100 0062                241      BSR         OUTPUT_CHAR         *print the char in D1
00001224                           242      *print the right character
00001224  E90A                     243      LSL.B       #4,D2               *get rid of left nibble
00001226  E80A                     244      LSR.B       #4,D2               *put right nibble in place
00001228  1202                     245      MOVE.B      D2,D1               *put right nibble in D1
0000122A  6100 0040                246      BSR         CONVERT_TO_ASCII    *convert value in D1, to ascii
0000122E  6100 0054                247      BSR         OUTPUT_CHAR         *print the char in D1
00001232  4E75                     248      RTS
00001234                           249  VALID_OPCODE 
00001234  548A                     250      ADD.L       #02,A2              *increment the current address because word is valid
00001236  BC7C 0000                251      CMP         #00,D6              *if leftover data not printed
0000123A  6700 0004                252      BEQ         PRINT_OPCODE_EA     *print just the opcode
0000123E  618A                     253      BSR         PRINT_DATA          *print unreadable data
00001240                           254                                      *and the opcode
00001240                           255  PRINT_OPCODE_EA
00001240  1C3C 0000                256      MOVE.B      #00,D6              *reset the increment counter
00001244  619C                     257      BSR         PRINT_ADDRESS       *print the data address
00001246  6100 005E                258      BSR         TAB                 *insert a space
0000124A  6100 000A                259      BSR         PRINT_OPCODE        *print out hte opcode and eA
0000124E  6100 FF5E                260      BSR         INCREMENT_LINE      *increment line counter (line was printed)
00001252  6000 FF1A                261      BRA         READ_MEMORY_LOOP    *read next byte.
00001256                           262      
00001256                           263  
00001256                           264  PRINT_OPCODE
00001256  43F9 00000500            265      LEA         STRING_START,A1     *put the starting address of the string into A1
0000125C  103C 000E                266      MOVE.B      #14,D0              *print null terminated string into A
00001260  4E4F                     267      TRAP        #15                 *output to terminal
00001262  2679 00000500            268      MOVE.L      STRING_START,A3     *reset the current string pointer
00001268  4E75                     269      RTS
0000126A                           270      
0000126A                           271      
0000126A                           272            
0000126A                           273      
0000126A                           274  RETURN_TO_SUBROUTINE
0000126A  4E75                     275      RTS
0000126C                           276    
0000126C                           277  CONVERT_TO_ASCII
0000126C  B23C 0009                278      CMP.B       #9,D1           *compare value with 9
00001270  6E00 000C                279      BGT         ALPH_CHAR       *convert to numeric ascii
00001274  6000 0002                280      BRA         NUMERIC_CHAR    *convert to alphabetical ascii
00001278                           281  NUMERIC_CHAR        
00001278  0601 0030                282      ADD.B       #48,D1          *convert to ascii value
0000127C  4E75                     283      RTS                         *continue converting
0000127E                           284  ALPH_CHAR
0000127E  0601 0037                285      ADD.B       #55,D1          *convert to ascii value
00001282  4E75                     286      RTS                         *continue converting            
00001284                           287  OUTPUT_CHAR
00001284  103C 0006                288      MOVE.B      #6,D0           *output whatever's in D1
00001288  4E4F                     289      TRAP        #15
0000128A  4E75                     290      RTS
0000128C                           291  
0000128C                           292  
0000128C                           293  IM_NEW_LINE
0000128C  43F9 00002072            294      LEA         M_NEW_LINE,A1      *load new line
00001292  103C 000E                295      MOVE.B      #14,D0          *load message
00001296  4E4F                     296      TRAP        #15             *display message
00001298  4E75                     297      RTS
0000129A                           298  IM_SPACE
0000129A  123C 0020                299      MOVE.B      #32,D1
0000129E  103C 0006                300      MOVE.B      #6,D0
000012A2  4E4F                     301      TRAP        #15
000012A4  4E75                     302      RTS
000012A6                           303  TAB
000012A6  43F9 00002051            304      LEA         M_TAB,A1
000012AC  103C 000E                305      MOVE.B      #14,D0
000012B0  4E4F                     306      TRAP        #15
000012B2  4E75                     307      RTS
000012B4                           308  DATA
000012B4  43F9 00002048            309      LEA         M_DATA,A1
000012BA  103C 000E                310      MOVE.B      #14,D0
000012BE  4E4F                     311      TRAP        #15
000012C0  4E75                     312      RTS
000012C2                           313      
000012C2                           314  END
000012C2                           315  
000012C2                           316  
000012C2                           317  
000012C2                           318  
000012C2                           319  
000012C2                           320  
000012C2                           321  
000012C2                           322  
000012C2                           323  
000012C2                           324  
000012C2                           325  
000012C2                           326  
000012C2                           327  
000012C2                           328  
000012C2                           329  
000012C2                           330  
000012C2                           331  
000012C2                           332  
000012C2                           333  
000012C2                           334  -------------------- end include --------------------
000012C2                           335      INCLUDE         'OP_jumpTable.X68'
000012C2                           336  VERIFY_OPCODE
000012C2  3200                     337      MOVE.W  D0,D1   *Copy instruction for modification
000012C4                           338      
000012C4                           339      **ISOLATE FIRST FOUR BITS**                                             
000012C4  E849                     340      LSR.W   #4,D1       *Shift left four bits
000012C6  E049                     341      LSR.W   #8,D1       *Shift left again (12 shifts total)
000012C8                           342      
000012C8  4242                     343      CLR     D2
000012CA  1401                     344      MOVE.B  D1,D2
000012CC                           345      
000012CC  41F9 000012DA            346      LEA     OP_JTAB,A0 
000012D2  C5FC 0006                347      MULS    #6, D2
000012D6  4EB0 2000                348      JSR     0(A0,D2)
000012DA                           349  
000012DA                           350  
000012DA                           351  
000012DA  4EF9 0000133C            352  OP_JTAB    JMP     OP0000      *ADDI
000012E0  4EF9 00001346            353      JMP     OP0001      *MOVE.B
000012E6  4EF9 00001350            354      JMP     OP0010      *MOVE.W, MOVEA(WORD)
000012EC  4EF9 00001354            355      JMP     OP0011      *MOVE.L, MOVEA(LONG) 
000012F2  4EF9 00001380            356      JMP     OP0100      *NOP, MOVEM, LEA, CLR, JSR, RTS
000012F8  4EF9 00001404            357      JMP     OP0101      *ADDQ
000012FE  4EF9 0000140E            358      JMP     OP0110      *Bcc
00001304  4EF9 00001428            359      JMP     OP0111      *MOVEQ
0000130A  4EF9 00001432            360      JMP     OP1000      *DIVU, OR
00001310  4EF9 0000145E            361      JMP     OP1001      *SUB
00001316  4EF8 11B6                362      JMP     INVALID_OPCODE
0000131A  4EF9 00001468            363      JMP     OP1011      *CMP
00001320  4EF9 00001472            364      JMP     OP1100      *MULS, AND
00001326  4EF9 0000149E            365      JMP     OP1101      *ADD, ADDA
0000132C  4EF9 000014CA            366      JMP     OP1110      *LSR, LSL, ASR, ASL, ROL, ROR
00001332  4EF8 11B6                367      JMP     INVALID_OPCODE
00001336                           368  
00001336                           369  
00001336                           370      
00001336  6000 FE7E                371      BRA    INVALID_OPCODE     *Subroutine to store as non-decodable
0000133A  4E75                     372      RTS
0000133C                           373  
0000133C                           374  OP0000
0000133C                           375      *SINGLE CODE, DO NOT NEED FURTHER CHECKING
0000133C                           376      *BEGIN OUTPUT
0000133C                           377      
0000133C  36F9 00001584            378      MOVE.W  ADDI,(A3)+      *Load 'ADDI' to Add Reg 1 and then increment
00001342  6000 0472                379      BRA     EA_ADDI         *Branch to EA analysis of the command
00001346                           380  
00001346                           381  OP0001  *SINGLE CODE, DO NOT NEED FURTHER CHECKING 
00001346                           382          *BEGIN OUTPUT
00001346                           383      
00001346  36F9 00001589            384      MOVE.W  MOVE,(A3)+     *Load 'MOVE.B' to Add Reg 1 and then increment
0000134C  6000 02A7                385      BRA     EA_MOVE        *Branch to EA analysis of the command
00001350                           386  
00001350                           387  OP0010
00001350                           388      *Identical to OP0011 for these purposes, branch there
00001350  6000 0002                389      BRA OP0011
00001354                           390  
00001354                           391  OP0011
00001354                           392      *MULTIPLE CODE, CHECK AND GET NEXT 3 BITS
00001354                           393  
00001354                           394      **ISOLATE NEXT BITS TO CHECK**
00001354  3200                     395      MOVE.W  D0,D1           *Copy instruction for modification
00001356  EF49                     396      LSL.W   #7,D1           *Shift left 7 bits 
00001358  EA49                     397      LSR.W   #5,D1           *Rotate right 5 bits
0000135A  E049                     398      LSR.W   #8,D1           *Shift right again (13 shifts total)
0000135C  0241 000F                399      ANDI.W  #$00F,D1        *Keep 3 bits
00001360                           400      
00001360  B27C 0001                401      CMP     #%001,D1      *Check for 0010 to eliminate CLR
00001364  6700 0010                402      BEQ     _MOVEA          *If equal, branch to CLR
00001368                           403      
00001368  6000 0002                404      BRA     _MOVE
0000136C                           405      
0000136C                           406  _MOVE
0000136C  36F9 00001589            407      MOVE.W  MOVE,(A3)+     *Load 'MOVE.L' to Add Reg 1 and then increment   
00001372  6000 0281                408      BRA.W     EA_MOVE        *Branch to EA analysis of the command
00001376                           409  
00001376                           410  _MOVEA
00001376  36F9 0000158E            411      MOVE.W  MOVEA,(A3)+    *Load 'MOVEA.L' to Add Reg 1 and then increment
0000137C  6000 02EC                412      BRA     EA_MOVEA       *Branch to EA analysis of the command
00001380                           413  
00001380                           414  OP0100
00001380                           415      *MULTIPLE CODE, CHECK AND GET NEXT 3 BITS
00001380  3200                     416       MOVE.W  D0,D1           *Copy instruction for modification
00001382                           417      
00001382  B27C 4E71                418      CMP     #%0100111001110001,D1   *Check to eliminate NOP
00001386  6700 005E                419      BEQ     _NOP
0000138A  B27C 4E75                420      CMP     #%0100111001110101,D1   *Check to eliminate RTS
0000138E  6700 0060                421      BEQ     _RTS
00001392                           422      
00001392  EC49                     423      LSR.W   #6,D1                   *Shift right 6 bits
00001394  B27C 013A                424      CMP     #%0000000100111010,D1   *Check to eliminate RTS
00001398  6700 0042                425      BEQ     _JSR
0000139C                           426      
0000139C                           427      **ISOLATE 4 BITS TO CHECK CLR**    
0000139C  3200                     428      MOVE.W  D0,D1           *Copy instruction for modification
0000139E  E949                     429      LSL.W   #4,D1           *Shift left 7 bits 
000013A0  E849                     430      LSR.W   #4,D1           *Rotate right 5 bits
000013A2  E049                     431      LSR.W   #8,D1           *Shift right again (13 shifts total)
000013A4  0241 000F                432      ANDI.W  #$000F,D1       *Keep 4 bits
000013A8                           433      
000013A8  B27C 0002                434      CMP     #%0010,D1       *Check for 0010 to eliminate CLR
000013AC  6700 001A                435      BEQ     _CLR            *If equal, branch to CLR
000013B0                           436  
000013B0                           437      **ISOLATE 3 BITS TO CHECK MOVEM**
000013B0  3200                     438      MOVE.W  D0,D1           *Copy instruction for modification
000013B2  ED49                     439      LSL.W   #6,D1           *Shift left 6 bits 
000013B4  EA49                     440      LSR.W   #5,D1           *Shift right 5 bits
000013B6  E049                     441      LSR.W   #8,D1           *Shift right again (13 shifts total)
000013B8  0241 000F                442      ANDI.W  #$00F,D1        *Keep 3 bits
000013BC                           443      
000013BC  B27C 0001                444      CMP     #%001,D1
000013C0  6700 0038                445      BEQ     _MOVEM
000013C4                           446      
000013C4  6000 000C                447      BRA     _LEA            *Else by process of elimination it must be LEA   
000013C8                           448      
000013C8                           449  _CLR
000013C8  36F9 00001594            450      MOVE.W  OPCLR,(A3)+     *Load 'CLR' to Add Reg 1 and then increment
000013CE  6000 05A6                451      BRA     EA_CLR          *Branch to EA analysis of the command
000013D2                           452  
000013D2                           453  _LEA
000013D2  36F9 00001598            454      MOVE.W  OPLEA,(A3)+     *Load 'LEA' to Add Reg 1 and then increment
000013D8  6000 0544                455      BRA     EA_LEA          *Branch to EA analysis of the command
000013DC                           456  
000013DC                           457  _JSR
000013DC  36F9 0000159C            458      MOVE.W  OPJSR,(A3)+     *Load 'JSR' to Add Reg 1 and then increment
000013E2  6000 06EA                459      BRA     EA_JSR          *Branch to EA analysis of the command
000013E6                           460  
000013E6                           461  _NOP
000013E6  36F9 000015A0            462      MOVE.W  OPNOP,(A3)+     *Load 'NOP' to Add Reg 1 and then increment
000013EC  6000 FE46                463      BRA     VALID_OPCODE          *Branch to EA analysis of the command      
000013F0                           464  
000013F0                           465  _RTS
000013F0  36F9 000015A4            466      MOVE.W  OPRTS,(A3)+     *Load 'RTS' to Add Reg 1 and then increment
000013F6  6000 FE3C                467      BRA     VALID_OPCODE          *Branch to EA analysis of the command      
000013FA                           468  
000013FA                           469  _MOVEM
000013FA  36F9 000015A8            470      MOVE.W  MOVEM,(A3)+     *Load 'MOVEM' to Add Reg 1 and then increment
00001400  6000 070A                471      BRA     EA_MOVEM        *Branch to EA analysis of the command
00001404                           472      
00001404                           473  OP0101
00001404                           474      *SINGLE CODE, DO NOT NEED FURTHER CHECKING
00001404                           475      *BEGIN OUTPUT
00001404                           476      
00001404  36F9 000015AE            477      MOVE.W  ADDQ,(A3)+      *Load 'AddQ' to Add Reg 1 and then increment
0000140A  6000 040C                478      BRA     EA_ADDQ         *Branch to EA analysis of the command
0000140E                           479      
0000140E                           480  OP0110
0000140E                           481      *SINGLE CODE, DO NOT NEED FURTHER CHECKING
0000140E                           482      *BEGIN OUTPUT
0000140E  3200                     483      MOVE.W  D0,D1
00001410  E949                     484      LSL.W   #4,D1
00001412  E849                     485      LSR.W   #4,D1
00001414  E049                     486      LSR.W   #8,D1
00001416  B23C 0000                487      CMP.B   #0,D1
0000141A  6700 FD9A                488      BEQ     INVALID_OPCODE
0000141E                           489      
0000141E  36F9 000015B3            490      MOVE.W  Bcc,(A3)+       *Load 'Bcc' to Add Reg 1 and then increment 
00001424  6000 0684                491      BRA     EA_BCC          *Branch to EA analysis of the command
00001428                           492  
00001428                           493  OP0111
00001428                           494      *SINGLE CODE, DO NOT NEED FURTHER CHECKING
00001428                           495      *BEGIN OUTPUT
00001428                           496      
00001428  36F9 000015B5            497      MOVE.W  MOVEQ,(A3)+     *Load 'MOVEQ' to Add Reg 1 and then increment
0000142E  6000 0292                498      BRA     EA_MOVEQ        *Branch to EA analysis of the command
00001432                           499      
00001432                           500  OP1000
00001432                           501      *MULTIPLE CODE, CHECK AND GET NEXT 3 BITS
00001432                           502      
00001432                           503      **ISOLATE NEXT BITS TO CHECK**
00001432  3200                     504      MOVE.W  D0,D1           *Copy instruction for modification
00001434  EF49                     505      LSL.W   #7,D1           *Shift left 7 bits 
00001436  EA49                     506      LSR.W   #5,D1           *Rotate right 5 bits
00001438  E049                     507      LSR.W   #8,D1           *Shift right again (13 shifts total)
0000143A  0241 000F                508      ANDI.W  #$00F,D1        *Keep 3 bits
0000143E                           509            
0000143E  B27C 0003                510      CMP     #%011,D1    *Check for 011 to eliminate DIVU
00001442  6700 0006                511      BEQ     _DIVU        *If equal, branch to DIVU
00001446  6000 000C                512      BRA     _OR          *Else must be OR, branch
0000144A                           513      
0000144A                           514  _DIVU
0000144A  36F9 000015BB            515      MOVE.W  DIVU,(A3)+      *Load 'DIVU' to Add Reg 1 and then increment
00001450  6000 047A                516      BRA     EA_MULS         *Branch to EA analysis of the command
00001454                           517  
00001454                           518  _OR
00001454  36F9 000015C0            519      MOVE.W  OR,(A3)+        *Load 'OR' to Add Reg 1 and then increment
0000145A  6000 02A0                520      BRA     EA_ADD           *Branch to EA analysis of the command
0000145E                           521  
0000145E                           522  OP1001
0000145E                           523      *SINGLE CODE, DO NOT NEED FURTHER CHECKING
0000145E                           524      *BEGIN OUTPUT
0000145E                           525      
0000145E  36F9 000015C3            526      MOVE.W  OPSUB,(A3)+     *Load 'SUB' to Add Reg 1 and then increment
00001464  6000 0296                527      BRA     EA_ADD          *Branch to EA analysis of the command
00001468                           528  
00001468                           529  OP1011
00001468                           530      *SINGLE CODE, DO NOT NEED FURTHER CHECKING
00001468                           531      *BEGIN OUTPUT
00001468  36F9 000015C7            532      MOVE.W  CMP,(A3)+     *Load 'CMP' to Add Reg 1 and then increment
0000146E  6000 05E0                533      BRA     EA_CMP          *Branch to EA analysis of the command
00001472                           534  
00001472                           535  OP1100
00001472                           536      *MULTIPLE CODE, CHECK AND GET NEXT 3 BITS
00001472                           537  
00001472  3200                     538      MOVE.W  D0,D1           *Copy instruction for modification
00001474  EF49                     539      LSL.W   #7,D1           *Shift left 7 bits 
00001476  EA49                     540      LSR.W   #5,D1           *Rotate right 5 bits
00001478  E049                     541      LSR.W   #8,D1           *Shift right again (13 shifts total)
0000147A  0241 000F                542      ANDI.W  #$00F,D1        *Keep 3 bits
0000147E                           543           
0000147E  B27C 0007                544      CMP     #%111,D1       *Check for 111 to eliminate MULS
00001482  6700 0006                545      BEQ     _MULS           *If equal, branch to MULS
00001486  6000 000C                546      BRA     _AND            *Else must be AND, branch
0000148A                           547      
0000148A                           548  _MULS
0000148A  36F9 000015CB            549      MOVE.W  MULS,(A3)+      *Load 'MULS' to Add Reg 1 and then increment
00001490  6000 043A                550      BRA     EA_MULS         *Branch to EA analysis of the command
00001494                           551  
00001494                           552  _AND
00001494  36F9 000015D0            553      MOVE.W  AND,(A3)+       *Load 'AND' to Add Reg 1 and then increment
0000149A  6000 0260                554      BRA     EA_ADD          *Branch to EA analysis of the command
0000149E                           555      
0000149E                           556  OP1101
0000149E                           557      *MULTIPLE CODE, CHECK AND GET NEXT 3 BITS  
0000149E                           558  
0000149E  3200                     559      MOVE.W  D0,D1           *Copy instruction for modification
000014A0  E149                     560      LSL.W   #8,D1           *Shift left 7 bits 
000014A2  EA49                     561      LSR.W   #5,D1           *Rotate left 5 bits
000014A4  E049                     562      LSR.W   #8,D1           *Shift left again (13 shifts total)
000014A6  0241 000F                563      ANDI.W  #$0F,D1         *Keep 3 bits
000014AA                           564                
000014AA  B27C 0003                565      CMP     #%11,D1         *Check for 011 to eliminate ADDA (Size dependant)
000014AE  6700 0010                566      BEQ     _ADDA           *If equal, branch to ADDA
000014B2  6000 0002                567      BRA     _ADD            *Else must be ADD, branch
000014B6                           568      
000014B6                           569  _ADD
000014B6  36F9 000015D4            570      MOVE.W  ADD,(A3)+       *Load 'ADD' to Add Reg 1 and then increment
000014BC  6000 023E                571      BRA     EA_ADD          *Branch to EA analysis of the command
000014C0                           572  
000014C0                           573  _ADDA
000014C0  36F9 000015D8            574      MOVE.W  ADDA,(A3)+      *Load 'ADDA' to Add Reg 1 and then increment
000014C6  6000 03AA                575      BRA     EA_ADDA         *Branch to EA analysis of the command
000014CA                           576      
000014CA                           577  OP1110
000014CA                           578      *MULTIPLE CODE, CHECK AND GET NEXT 3 BITS
000014CA                           579        
000014CA  3200                     580      MOVE.W  D0,D1           *Copy instruction for modification
000014CC  EF49                     581      LSL.W   #7,D1           *Shift left 7 bits 
000014CE  EA49                     582      LSR.W   #5,D1           *Rotate right 5 bits
000014D0  E049                     583      LSR.W   #8,D1           *Shift right again (13 shifts total)
000014D2  0241 000F                584      ANDI.W  #$00F,D1        *Keep 3 bits
000014D6                           585                    
000014D6  B27C 0001                586      CMP     #%001,D1        *Check for 001 to eliminate LSd instructions
000014DA  6700 001C                587      BEQ     _LSd            *If equal, branch to LSd to determine LSR or LSL
000014DE                           588  
000014DE                           589      **ELSE CONTINUE CHECKING**
000014DE  3200                     590      MOVE.W  D0,D1           *Copy instruction for modification
000014E0  E149                     591      LSL.W   #8,D1          *Shift left 7 bits
000014E2  E749                     592      LSL.W   #3,D1 
000014E4  EA49                     593      LSR.W   #5,D1           *Rotate left 5 bits
000014E6  E049                     594      LSR.W   #8,D1           *Shift left again (13 shifts total)
000014E8  0241 000F                595      ANDI.W  #$0F,D1         *Keep 2 bits
000014EC                           596      
000014EC                           597      **BEGIN ELIMINATION 'IF/ELSE' STATEMENTS                   
000014EC  B27C 0000                598      CMP     #%00,D1         *Check for 00 to eliminate ASd
000014F0  6700 0032                599      BEQ     _ASd            *If equal, branch to ASd to determine ASR or ASL
000014F4  6000 005C                600      BRA     _ROd            *Else must be a ROd instruction, branch to determine
000014F8                           601      
000014F8                           602  _LSd   
000014F8                           603   
000014F8  3200                     604      MOVE.W  D0,D1           *Copy instruction for modification
000014FA  EF49                     605      LSL.W   #7,D1           *Shift left 7 bits 
000014FC  EE49                     606      LSR.W   #7,D1           *Rotate right 5 bits
000014FE  E049                     607      LSR.W   #8,D1           *Shift right again (13 shifts total)
00001500  0241 000F                608      ANDI.W  #$F,D1          *Keep 3 bits
00001504                           609  
00001504  B27C 0000                610      CMP     #%0,D1        *Check for 011 to eliminate LSR
00001508  6700 0010                611      BEQ     _LSR            *If equal, branch to LSR
0000150C  6000 0002                612      BRA     _LSL            *Else must be LSL, branch
00001510                           613  
00001510                           614  _LSL    
00001510  36F9 000015DD            615      MOVE.W  LSL,(A3)+       *Load 'LSL' to Add Reg 1 and then increment
00001516  6000 04A4                616      BRA     EA_LSD         *Branch to EA analysis of the command
0000151A                           617  
0000151A                           618  _LSR
0000151A  36F9 000015E1            619      MOVE.W  LSR,(A3)+       *Load 'LSR' to Add Reg 1 and then increment
00001520  6000 049A                620      BRA     EA_LSD          *Branch to EA analysis of the command
00001524                           621  
00001524                           622  _ASd
00001524                           623  
00001524  3200                     624      MOVE.W  D0,D1           *Copy instruction for modification
00001526  E149                     625      LSL.W   #8,D1           *Shift left 7 bits 
00001528  E549                     626      LSL.W   #2,D1           *Shift left 7 bits
0000152A  EA49                     627      LSR.W   #5,D1           *Rotate right 5 bits
0000152C  E049                     628      LSR.W   #8,D1           *Shift right again (13 shifts total)
0000152E  0241 000F                629      ANDI.W  #$00F,D1        *Keep 3 bits
00001532                           630     
00001532  B27C 0000                631      CMP     #%000,D1        *Check for 000 to eliminate ASR
00001536  6700 0010                632      BEQ     _ASR            *If equal, branch to ASR
0000153A  6000 0002                633      BRA     _ASL            *Else must be ASL, branch
0000153E                           634  
0000153E                           635  _ASL    
0000153E  36F9 000015E5            636      MOVE.W  ASL,(A3)+       *Load 'ASL' to Add Reg 1 and then increment
00001544  6000 0476                637      BRA     EA_LSD          *Branch to EA analysis of the command
00001548                           638  
00001548                           639  _ASR
00001548  36F9 000015E9            640      MOVE.W  ASR,(A3)+       *Load 'ASR' to Add Reg 1 and then increment
0000154E  6000 046C                641      BRA     EA_LSD          *Branch to EA analysis of the command
00001552                           642  
00001552                           643  _ROd
00001552                           644  
00001552  3200                     645      MOVE.W  D0,D1           *Copy instruction for modification
00001554  E549                     646      LSL.W   #2,D1           *Shift left 7 bits
00001556  E149                     647      LSL.W   #8,D1           *Shift left 7 bits 
00001558  EA49                     648      LSR.W   #5,D1           *Rotate right 5 bits
0000155A  E049                     649      LSR.W   #8,D1           *Shift right again (13 shifts total)
0000155C  0241 000F                650      ANDI.W  #$00F,D1        *Keep 3 bits
00001560                           651  
00001560                           652      **BEGIN ELIMINATION 'IF/ELSE' STATEMENTS   
00001560  B27C 0003                653      CMP     #%011,D1        *Check for 011 to eliminate ROR
00001564  6700 0010                654      BEQ     _ROR            *If equal, branch to ROR
00001568  6000 0002                655      BRA     _ROL            *Else must be ROL, branch
0000156C                           656      
0000156C                           657  _ROL    
0000156C  36F9 000015ED            658      MOVE.W  ROL,(A3)+       *Load 'ROL' to Add Reg 1 and then increment
00001572  6000 0448                659      BRA     EA_LSD          *Branch to EA analysis of the command
00001576                           660  
00001576                           661  _ROR
00001576  36F9 000015F1            662      MOVE.W  ROR,(A3)+       *Load 'ROR' to Add Reg 1 and then increment
0000157C  6000 043E                663      BRA     EA_LSD          *Branch to EA analysis of the command
00001580                           664  
00001580  FFFF FFFF                665      SIMHALT
00001584                           666  
00001584= 41 44 44 49 00           667  ADDI    DC.B    'ADDI',0
00001589= 4D 4F 56 45 00           668  MOVE    DC.B    'MOVE',0
0000158E= 4D 4F 56 45 41 00        669  MOVEA   DC.B    'MOVEA',0
00001594= 43 4C 52 00              670  OPCLR   DC.B    'CLR',0
00001598= 4C 45 41 00              671  OPLEA   DC.B    'LEA',0
0000159C= 4A 53 52 00              672  OPJSR   DC.B    'JSR',0
000015A0= 4E 4F 50 00              673  OPNOP   DC.B    'NOP',0
000015A4= 52 54 53 00              674  OPRTS   DC.B    'RTS',0
000015A8= 4D 4F 56 45 4D 00        675  MOVEM   DC.B    'MOVEM',0
000015AE= 41 44 44 51 00           676  ADDQ    DC.B    'ADDQ',0
000015B3= 42 00                    677  Bcc     DC.B    'B',0
000015B5= 4D 4F 56 45 51 00        678  MOVEQ   DC.B    'MOVEQ',0
000015BB= 44 49 56 55 00           679  DIVU    DC.B    'DIVU',0
000015C0= 4F 52 00                 680  OR      DC.B    'OR',0
000015C3= 53 55 42 00              681  OPSUB   DC.B    'SUB',0
000015C7= 43 4D 50 00              682  CMP     DC.B    'CMP',0
000015CB= 4D 55 4C 53 00           683  MULS    DC.B    'MULS',0
000015D0= 41 4E 44 00              684  AND     DC.B    'AND',0
000015D4= 41 44 44 00              685  ADD     DC.B    'ADD',0
000015D8= 41 44 44 41 00           686  ADDA    DC.B    'ADDA',0
000015DD= 4C 53 4C 00              687  LSL     DC.B    'LSL',0
000015E1= 4C 53 52 00              688  LSR     DC.B    'LSR',0
000015E5= 41 53 4C 00              689  ASL     DC.B    'ASL',0
000015E9= 41 53 52 00              690  ASR     DC.B    'ASR',0
000015ED= 52 4F 4C 00              691  ROL     DC.B    'ROL',0
000015F1= 52 4F 52 00              692  ROR     DC.B    'ROR',0
000015F5                           693  
000015F5                           694  -------------------- end include --------------------
000015F5                           695      INCLUDE         'EFFECTIVE_ADDRESSES.X68'
000015F5                           696  
000015F5                           697      *EXAMPLE, MOVE A HEX CODE INTO D6
000015F5                           698      *CALL THE CORRESPONDING EA CODE
000015F5                           699      *MOVE.W     #$2E7C, D6
000015F5                           700      *BRA         EA_MOVE
000015F5                           701      *END EXAMPLE
000015F5                           702      
000015F5                           703  EA_MOVE      *1 invalid; done
000015F6  3C00                     704      MOVE.W      D0, D6 *DO THIS AT THE BEGGINING OF EVERY EA 
000015F8                           705      
000015F8  3806                     706      MOVE.W      D6, D4      *
000015FA  E04C                     707      LSR.W       #8, D4      *
000015FC  E84C                     708      LSR.W       #4, D4      *D4 = SIZE
000015FE  4EB9 00001D48            709      JSR GET_SIZE
00001604                           710      
00001604  3806                     711      MOVE.W      D6, D4      *
00001606  E14C                     712      LSL.W       #8, D4      *
00001608  E54C                     713      LSL.W       #2, D4
0000160A  E04C                     714      LSR.W       #8, D4      *
0000160C  EA4C                     715      LSR.W       #5, D4      *D4 = <0000 0000> D4 = SOURCE MODE
0000160E                           716      
0000160E  3A06                     717      MOVE.W      D6, D5      *SHIFT LEFT 13; RIGHT 13
00001610  E14D                     718      LSL.W       #8, D5  
00001612  EB4D                     719      LSL.W       #5, D5      *
00001614  E04D                     720      LSR.W       #8, D5
00001616  EA4D                     721      LSR.W       #5, D5      *D5 = SOURCE REGISTER
00001618                           722      
00001618  4EB9 00001E3A            723      JSR         MODE_CHOOSER
0000161E  41F9 00001C8C            724      LEA         MODE_JUMP, A0   *LOAD MODE JUMP TABLE
00001624  C9FC 0006                725      MULS        #6, D4          *GET JUMP
00001628  4EB0 4000                726      JSR         0(A0, D4)       *JUMP
0000162C  4EB9 00001EAA            727      JSR COMMA
00001632  4EB9 00001F0C            728      JSR SPACE
00001638  3806                     729      MOVE.W      D6, D4      *
0000163A  EF4C                     730      LSL.W       #7, D4      *
0000163C  EE4C                     731      LSR.W       #7, D4      *
0000163E  EC4C                     732      LSR.W       #6, D4      *D4 = DESTINATION MODE
00001640  4EB9 00001C02            733      JSR         MOVE_ERROR_CHECK 
00001646                           734      
00001646  3A06                     735      MOVE.W      D6, D5      *
00001648  E94D                     736      LSL.W       #4, D5      *
0000164A  E04D                     737      LSR.W       #8, D5      *
0000164C  EA4D                     738      LSR.W       #5, D5      *D5 = DESTINATION REGISTER
0000164E                           739      
0000164E  4EB9 00001E3A            740      JSR         MODE_CHOOSER
00001654  41F9 00001C8C            741      LEA         MODE_JUMP, A0   *LOAD MODE JUMP
0000165A  C9FC 0006                742      MULS        #6, D4          *GET JUMP
0000165E  4EB0 4000                743      JSR         0(A0, D4)       *JUMP
00001662  16BC 0000                744      MOVE.B      #00, (A3) 
00001666  6000 FBCC                745      BRA         VALID_OPCODE
0000166A                           746  EA_MOVEA        *0 invalid
0000166A  3C00                     747      MOVE.W      D0, D6
0000166C                           748  
0000166C  3806                     749      MOVE.W      D6, D4      *GETTING SIZE
0000166E  E04C                     750      LSR.W       #8, D4      *
00001670  E84C                     751      LSR.W       #4, D4      *SHIFT 12 BITS RIGHT
00001672  4EB9 00001D48            752      JSR         GET_SIZE    *D4 = SIZE
00001678                           753      
00001678  3806                     754      MOVE.W      D6, D4      *GETTING SOURCE MODE
0000167A  E14C                     755      LSL.W       #8, D4      *
0000167C  E54C                     756      LSL.W       #2, D4      *SHIFT 10 BITS LEFT; 13 RIGHT
0000167E  E04C                     757      LSR.W       #8, D4      *
00001680  EA4C                     758      LSR.W       #5, D4      *D4 = SOURCE MODE
00001682                           759  
00001682  3A06                     760      MOVE.W      D6, D5      *GETTING SOURCE REGISTER
00001684  E14D                     761      LSL.W       #8, D5      *
00001686  EB4D                     762      LSL.W       #5, D5      *SHIFT LEFT 13; RIGHT 13
00001688  E04D                     763      LSR.W       #8, D5      *
0000168A  EA4D                     764      LSR.W       #5, D5      *D5 = SOURCE REGISTER
0000168C                           765      
0000168C  4EB9 00001E3A            766      JSR         MODE_CHOOSER  *INCASE MODE IS $111
00001692  41F9 00001C8C            767      LEA         MODE_JUMP, A0 *LOAD MODE JUMP TABLE
00001698  C9FC 0006                768      MULS        #6, D4        *GET JUMP
0000169C  4EB0 4000                769      JSR         0(A0, D4)     *JUMP
000016A0  4EB9 00001EAA            770      JSR         COMMA
000016A6  4EB9 00001F0C            771      JSR         SPACE
000016AC  3A06                     772      MOVE.W      D6, D5      *GET THE DESTINATION REGISTER
000016AE  E94D                     773      LSL.W       #4, D5      *
000016B0  E04D                     774      LSR.W       #8, D5      *SHIFT 4 BITS LEFT; 13 RIGHT
000016B2  EA4D                     775      LSR.W       #5, D5      *D5 = DESTINATION REGISTER
000016B4                           776      
000016B4  4EB9 00001CCA            777      JSR         ADDR_1
000016BA  16BC 0000                778      MOVE.B      #00, (A3)
000016BE  6000 FB74                779      BRA         VALID_OPCODE
000016C2                           780  EA_MOVEQ        *0 invalid
000016C2  3C00                     781      MOVE.W      D0, D6
000016C4                           782  
000016C4  4EB9 00001F0C            783      JSR SPACE
000016CA  4EB9 00001EB2            784      JSR POUND
000016D0  4EB9 00001F14            785      JSR CASH
000016D6  6100 0786                786      BSR OUTPUT_HEX    
000016DA  4EB9 00001EAA            787      JSR COMMA
000016E0  4EB9 00001F0C            788      JSR SPACE
000016E6  3A06                     789      MOVE.W      D6, D5      *GET THE DESTINATION REGISTER
000016E8  E94D                     790      LSL.W       #4, D5      *
000016EA  E04D                     791      LSR.W       #8, D5      *
000016EC  EA4D                     792      LSR.W       #5, D5      * D5 = DESTINATION REGISTER
000016EE                           793      
000016EE  4EB9 00001CBC            794      JSR         DATA_0
000016F4  16BC 0000                795      MOVE.B      #00, (A3)
000016F8  6000 FB3A                796      BRA         VALID_OPCODE
000016FC                           797  EA_ADD          *3 invalid; done
000016FC                           798  
000016FC  3C00                     799      MOVE.W      D0, D6
000016FE                           800  
000016FE  3806                     801      MOVE.W      D6, D4      *GETTING OPMODE AKA SIZE
00001700  EF4C                     802      LSL.W       #7, D4      * 
00001702  EE4C                     803      LSR.W       #7, D4      *
00001704  EC4C                     804      LSR.W       #6, D4      *D4 = OPMODE AKA SIZE
00001706  4EB9 00001D86            805      JSR         GET_OPMODE_MATH *PRINTS THE SIZE
0000170C                           806  
0000170C  B83C 0003                807      CMP.B       #3, D4
00001710  6D00 000A                808      BLT         DN_VERSION
00001714  B83C 0003                809      CMP.B       #3, D4
00001718  6E00 004C                810      BGT         EA_VERSION
0000171C                           811  DN_VERSION *EA IS SOURCE, REGISTER IS DESTINATION <EA> + DN -> DN
0000171C  3806                     812      MOVE.W      D6, D4      
0000171E  E14C                     813      LSL.W       #8, D4      *LEFT 10; RIGHT 13
00001720  E54C                     814      LSL.W       #2, D4
00001722  E04C                     815      LSR.W       #8, D4      *
00001724  EA4C                     816      LSR.W       #5, D4      *D4 = EA MODE
00001726                           817      
00001726  3A06                     818      MOVE.W      D6, D5      *SHIFT LEFT 13; RIGHT 13
00001728  E14D                     819      LSL.W       #8, D5  
0000172A  EB4D                     820      LSL.W       #5, D5      *
0000172C  E04D                     821      LSR.W       #8, D5
0000172E  EA4D                     822      LSR.W       #5, D5      * D5 = EA REGISTER
00001730                           823      
00001730  4EB9 00001E3A            824      JSR         MODE_CHOOSER    *IF A WORD OR LONG    
00001736  41F9 00001C8C            825      LEA         MODE_JUMP, A0   *LOAD MODE JUMP TABLE
0000173C  C9FC 0006                826      MULS        #6, D4          *GET JUMP
00001740  4EB0 4000                827      JSR         0(A0, D4)       *JUMP
00001744                           828          
00001744  4EB9 00001EAA            829      JSR         COMMA
0000174A  4EB9 00001F0C            830      JSR         SPACE
00001750                           831      
00001750  3A06                     832      MOVE.W      D6, D5      *LEFT 4; RIGHT 13
00001752  E94D                     833      LSL.W       #4, D5      *
00001754  E04D                     834      LSR.W       #8, D5      *
00001756  EA4D                     835      LSR.W       #5, D5      *D5 DESTINATION REGISTER
00001758                           836      
00001758  4EB9 00001CBC            837      JSR         DATA_0
0000175E  16BC 0000                838      MOVE.B      #00, (A3)
00001762  6000 FAD0                839      BRA         VALID_OPCODE
00001766                           840  EA_VERSION
00001766  3A06                     841      MOVE.W      D6, D5      *LEFT 4; RIGHT 13
00001768  E94D                     842      LSL.W       #4, D5      *
0000176A  E04D                     843      LSR.W       #8, D5      *
0000176C  EA4D                     844      LSR.W       #5, D5      *D5 DESTINATION REGISTER
0000176E  4EB9 00001CBC            845      JSR         DATA_0
00001774                           846      
00001774  4EB9 00001EAA            847      JSR         COMMA
0000177A  4EB9 00001F0C            848      JSR         SPACE
00001780                           849      
00001780  3806                     850      MOVE.W      D6, D4      
00001782  E14C                     851      LSL.W       #8, D4      *LEFT 10; RIGHT 13
00001784  E54C                     852      LSL.W       #2, D4
00001786  E04C                     853      LSR.W       #8, D4      *
00001788  EA4C                     854      LSR.W       #5, D4      *D4 = EA MODE
0000178A                           855      
0000178A  3A06                     856      MOVE.W      D6, D5      *SHIFT LEFT 13; RIGHT 13
0000178C  E14D                     857      LSL.W       #8, D5  
0000178E  EB4D                     858      LSL.W       #5, D5      *
00001790  E04D                     859      LSR.W       #8, D5
00001792  EA4D                     860      LSR.W       #5, D5      * D5 = EA REGISTER
00001794                           861      
00001794                           862      *the only way there could be an error is if 
00001794                           863      *we are in THIS addressing mo
00001794                           864      
00001794  4EB9 00001E3A            865      JSR         MODE_CHOOSER    *IF A WORD OR LONG 
0000179A  4EB9 00001C0C            866      JSR         ADD_ERROR_CHECK
000017A0  41F9 00001C8C            867      LEA         MODE_JUMP, A0   *LOAD MODE JUMP TABLE
000017A6  C9FC 0006                868      MULS        #6, D4          *GET JUMP
000017AA  4EB0 4000                869      JSR         0(A0, D4)       *JUMP
000017AE                           870      
000017AE  16BC 0000                871      MOVE.B      #00, (A3)
000017B2  6000 FA80                872      BRA         VALID_OPCODE
000017B6                           873  EA_ADDI  *2 invalid; DONE
000017B6  3C00                     874      MOVE.W      D0, D6
000017B8                           875      
000017B8  3806                     876      MOVE.W      D6, D4      *
000017BA  E14C                     877      LSL.W       #8, D4      *
000017BC  E04C                     878      LSR.W       #8, D4      *
000017BE  EC4C                     879      LSR.W       #6, D4      *D4 = SIZE
000017C0  4EB9 00001DD8            880      JSR         GET_SIZE_ADDI
000017C6  4EB9 00001EB2            881      JSR         POUND
000017CC  4EB9 00001F14            882      JSR         CASH
000017D2  6100 068A                883      BSR         OUTPUT_HEX
000017D6  4EB9 00001EAA            884      JSR         COMMA
000017DC  4EB9 00001F0C            885      JSR         SPACE
000017E2  3806                     886      MOVE.W      D6, D4      
000017E4  E14C                     887      LSL.W       #8, D4      *LEFT 10; RIGHT 13
000017E6  E54C                     888      LSL.W       #2, D4
000017E8  E04C                     889      LSR.W       #8, D4      *
000017EA  EA4C                     890      LSR.W       #5, D4      *D4 = EA MODE
000017EC                           891      
000017EC  3A06                     892      MOVE.W      D6, D5      *SHIFT LEFT 13; RIGHT 13
000017EE  E14D                     893      LSL.W       #8, D5  
000017F0  EB4D                     894      LSL.W       #5, D5      *
000017F2  E04D                     895      LSR.W       #8, D5
000017F4  EA4D                     896      LSR.W       #5, D5      * D5 = EA REGISTER
000017F6                           897      
000017F6  4EB9 00001E3A            898      JSR         MODE_CHOOSER    *IF A WORD OR LONG  
000017FC  4EB9 00001C26            899      JSR         ADDI_ERROR_CHECK
00001802  41F9 00001C8C            900      LEA         MODE_JUMP, A0   *LOAD MODE JUMP TABLE
00001808  C9FC 0006                901      MULS        #6, D4          *GET JUMP
0000180C  4EB0 4000                902      JSR         0(A0, D4)       *JUMP'
00001810                           903      
00001810  16BC 0000                904      MOVE.B      #00, (A3)
00001814  6000 FA1E                905      BRA         VALID_OPCODE
00001818                           906  EA_ADDQ     *0 INVALID
00001818  3C00                     907      MOVE.W      D0, D6
0000181A                           908      
0000181A  3806                     909      MOVE.W      D6, D4
0000181C  E14C                     910      LSL.W       #8, D4
0000181E  E04C                     911      LSR.W       #8, D4
00001820  EC4C                     912      LSR.W       #6, D4
00001822  4EB9 00001DD8            913      JSR         GET_SIZE_ADDI    *PRINT SIZE
00001828                           914      
00001828  3A06                     915      MOVE.W      D6, D5      *GETTING DATA
0000182A  E94D                     916      LSL.W       #4, D5      *SHIFT LEFT 4; RIGHT 13
0000182C  E04D                     917      LSR.W       #8, D5      *
0000182E  EA4D                     918      LSR.W       #5, D5      *D5 = DATA
00001830  4EB9 00001DBE            919      JSR         GET_DATA
00001836  4EB9 00001EAA            920      JSR COMMA
0000183C  4EB9 00001F0C            921      JSR SPACE
00001842  3806                     922      MOVE.W      D6, D4      *GETTING EA MODE
00001844  E14C                     923      LSL.W       #8, D4      *
00001846  E54C                     924      LSL.W       #2, D4      *SHIFT 10 LEFT; 13 RIGHT
00001848  E04C                     925      LSR.W       #8, D4      *
0000184A  EA4C                     926      LSR.W       #5, D4      *D4 = EA MODE
0000184C                           927      
0000184C  3A06                     928      MOVE.W      D6, D5      *GETTING EA REGISTER
0000184E  E14D                     929      LSL.W       #8, D5      *
00001850  EB4D                     930      LSL.W       #5, D5      *SHIFT LEFT 13; RIGHT 13
00001852  E04D                     931      LSR.W       #8, D5      *
00001854  EA4D                     932      LSR.W       #5, D5      *D5 = EA REGISTER
00001856                           933      
00001856  4EB9 00001E3A            934      JSR         MODE_CHOOSER
0000185C  41F9 00001C8C            935      LEA         MODE_JUMP, A0   *LOAD MODE JUMP
00001862  C9FC 0006                936      MULS        #6, D4          *GET JUMP
00001866  4EB0 4000                937      JSR         0(A0, D4)       *JUMP
0000186A                           938      
0000186A  16BC 0000                939      MOVE.B      #00, (A3)
0000186E                           940      
0000186E  6000 F9C4                941      BRA         VALID_OPCODE
00001872                           942  EA_ADDA         *0 INVALID
00001872  3C00                     943      MOVE.W      D0, D6
00001874                           944      
00001874  3806                     945      MOVE.W      D6, D4      *GETTING OPMODE AKA SIZE
00001876  EF4C                     946      LSL.W       #7, D4      * 
00001878  EE4C                     947      LSR.W       #7, D4      *
0000187A  EC4C                     948      LSR.W       #6, D4      *D4 = OPMODE AKA SIZE
0000187C  4EB9 00001D6E            949      JSR         GET_OPMODE
00001882                           950      
00001882  3806                     951      MOVE.W      D6, D4      *GETTING SOURCE MODE
00001884  E14C                     952      LSL.W       #8, D4      *
00001886  E54C                     953      LSL.W       #2, D4      *SHIFT 10 BITS LEFT; 13 RIGHT
00001888  E04C                     954      LSR.W       #8, D4      *
0000188A  EA4C                     955      LSR.W       #5, D4      *D4 = SOURCE MODE
0000188C                           956      
0000188C  3A06                     957      MOVE.W      D6, D5      *GETTING SOURCE REGISTER
0000188E  E14D                     958      LSL.W       #8, D5      *
00001890  EB4D                     959      LSL.W       #5, D5      *SHIFT LEFT 13; RIGHT 13
00001892  E04D                     960      LSR.W       #8, D5      *
00001894  EA4D                     961      LSR.W       #5, D5      *D5 = SOURCE REGISTER
00001896                           962      
00001896  4EB9 00001E3A            963      JSR         MODE_CHOOSER  *INCASE MODE IS $111
0000189C  41F9 00001C8C            964      LEA         MODE_JUMP, A0 *LOAD MODE JUMP TABLE
000018A2  C9FC 0006                965      MULS        #6, D4        *GET JUMP
000018A6  4EB0 4000                966      JSR         0(A0, D4)     *JUMP
000018AA  4EB9 00001EAA            967      JSR COMMA 
000018B0  4EB9 00001F0C            968      JSR SPACE
000018B6  3A06                     969      MOVE.W      D6, D5      *GET THE DESTINATION REGISTER
000018B8  E94D                     970      LSL.W       #4, D5      *
000018BA  E04D                     971      LSR.W       #8, D5      *SHIFT 4 BITS LEFT; 13 RIGHT
000018BC  EA4D                     972      LSR.W       #5, D5      *D5 = DESTINATION REGISTER
000018BE                           973      
000018BE  4EB9 00001CCA            974      JSR         ADDR_1
000018C4  16BC 0000                975      MOVE.B      #00, (A3)
000018C8                           976      
000018C8  6000 F96A                977      BRA         VALID_OPCODE
000018CC                           978  EA_MULS                *1 INVALID;
000018CC                           979  
000018CC  3C00                     980      MOVE.W      D0, D6
000018CE                           981      
000018CE  4EB9 00001F0C            982      JSR         SPACE
000018D4  3806                     983      MOVE.W      D6, D4      
000018D6  E14C                     984      LSL.W       #8, D4      *LEFT 10; RIGHT 13
000018D8  E54C                     985      LSL.W       #2, D4
000018DA  E04C                     986      LSR.W       #8, D4      *
000018DC  EA4C                     987      LSR.W       #5, D4      *D4 = EA MODE
000018DE                           988      
000018DE  3A06                     989      MOVE.W      D6, D5      *SHIFT LEFT 13; RIGHT 13
000018E0  E14D                     990      LSL.W       #8, D5  
000018E2  EB4D                     991      LSL.W       #5, D5      *
000018E4  E04D                     992      LSR.W       #8, D5
000018E6  EA4D                     993      LSR.W       #5, D5      * D5 = EA REGISTER
000018E8                           994      
000018E8  4EB9 00001E3A            995      JSR         MODE_CHOOSER    *IF A WORD OR LONG    
000018EE  41F9 00001C8C            996      LEA         MODE_JUMP, A0   *LOAD MODE JUMP TABLE
000018F4  C9FC 0006                997      MULS        #6, D4          *GET JUMP
000018F8  4EB0 4000                998      JSR         0(A0, D4)       *JUMP
000018FC  4EB9 00001EAA            999      JSR         COMMA
00001902  4EB9 00001F0C           1000      JSR         SPACE
00001908  3A06                    1001      MOVE.W      D6, D5      *LEFT 4; RIGHT 13
0000190A  E94D                    1002      LSL.W       #4, D5      *
0000190C  E04D                    1003      LSR.W       #8, D5      *
0000190E  EA4D                    1004      LSR.W       #5, D5      *D5 DESTINATION REGISTER
00001910                          1005      
00001910  4EB9 00001CBC           1006      JSR         DATA_0
00001916  16BC 0000               1007      MOVE.B      #00, (A3)
0000191A                          1008      
0000191A  6000 F918               1009      BRA         VALID_OPCODE
0000191E                          1010  EA_LEA          *5 INVALIDS; DONE
0000191E  3C00                    1011      MOVE.W      D0, D6
00001920                          1012      
00001920  4EB9 00001F0C           1013      JSR         SPACE
00001926  3806                    1014      MOVE.W      D6, D4      *GETTING SOURCE MODE
00001928  E14C                    1015      LSL.W       #8, D4      *
0000192A  E54C                    1016      LSL.W       #2, D4      *SHIFT 10 BITS LEFT; 13 RIGHT
0000192C  E04C                    1017      LSR.W       #8, D4      *
0000192E  EA4C                    1018      LSR.W       #5, D4      *D4 = SOURCE MODE
00001930                          1019      
00001930  3A06                    1020      MOVE.W      D6, D5      *GETTING SOURCE REGISTER
00001932  E14D                    1021      LSL.W       #8, D5      *
00001934  EB4D                    1022      LSL.W       #5, D5      *SHIFT LEFT 13; RIGHT 13
00001936  E04D                    1023      LSR.W       #8, D5      *
00001938  EA4D                    1024      LSR.W       #5, D5      *D5 = SOURCE REGISTER
0000193A                          1025      
0000193A  4EB9 00001E3A           1026      JSR         MODE_CHOOSER  *INCASE MODE IS $111
00001940  4EB9 00001C38           1027      JSR         LEA_ERROR_CHECK
00001946  41F9 00001C8C           1028      LEA         MODE_JUMP, A0 *LOAD MODE JUMP TABLE
0000194C  C9FC 0006               1029      MULS        #6, D4        *GET JUMP
00001950  4EB0 4000               1030      JSR         0(A0, D4)     *JUMP
00001954  4EB9 00001EAA           1031      JSR COMMA
0000195A  4EB9 00001F0C           1032      JSR SPACE
00001960  3A06                    1033      MOVE.W      D6, D5      *GET THE DESTINATION REGISTER
00001962  E94D                    1034      LSL.W       #4, D5      *
00001964  E04D                    1035      LSR.W       #8, D5      *SHIFT 4 BITS LEFT; 13 RIGHT
00001966  EA4D                    1036      LSR.W       #5, D5      *D5 = DESTINATION REGISTER
00001968                          1037      
00001968  4EB9 00001CCA           1038      JSR         ADDR_1
0000196E  16BC 0000               1039      MOVE.B      #00, (A3)
00001972                          1040      
00001972  6000 F8C0               1041      BRA         VALID_OPCODE
00001976                          1042  EA_CLR          *2 INVALID; DONE
00001976  3C00                    1043      MOVE.W      D0, D6
00001978                          1044      
00001978  3806                    1045      MOVE.W      D6, D4
0000197A  E14C                    1046      LSL.W       #8, D4      *
0000197C  E04C                    1047      LSR.W       #8, D4      *
0000197E  EC4C                    1048      LSR.W       #6, D4      *D4 = SIZE
00001980  4EB9 00001DD8           1049      JSR         GET_SIZE_ADDI
00001986  3806                    1050      MOVE.W      D6, D4      
00001988  E14C                    1051      LSL.W       #8, D4      *LEFT 10; RIGHT 13
0000198A  E54C                    1052      LSL.W       #2, D4
0000198C  E04C                    1053      LSR.W       #8, D4      *
0000198E  EA4C                    1054      LSR.W       #5, D4      *D4 = EA MODE
00001990                          1055      
00001990  3A06                    1056      MOVE.W      D6, D5      *SHIFT LEFT 13; RIGHT 13
00001992  E14D                    1057      LSL.W       #8, D5  
00001994  EB4D                    1058      LSL.W       #5, D5      *
00001996  E04D                    1059      LSR.W       #8, D5
00001998  EA4D                    1060      LSR.W       #5, D5      * D5 = EA REGISTER
0000199A                          1061      
0000199A  4EB9 00001E3A           1062      JSR         MODE_CHOOSER    *IF A WORD OR LONG  
000019A0  4EB9 00001C26           1063      JSR         ADDI_ERROR_CHECK  
000019A6  41F9 00001C8C           1064      LEA         MODE_JUMP, A0   *LOAD MODE JUMP TABLE
000019AC  C9FC 0006               1065      MULS        #6, D4          *GET JUMP
000019B0  4EB0 4000               1066      JSR         0(A0, D4)       *JUMP
000019B4                          1067      
000019B4  16BC 0000               1068      MOVE.B      #00, (A3)
000019B8                          1069      
000019B8  6000 F87A               1070      BRA         VALID_OPCODE
000019BC                          1071  EA_LSD          *3 INVALID; DONE
000019BC  3C00                    1072      MOVE.W      D0, D6
000019BE                          1073      
000019BE  3806                    1074      MOVE.W      D6, D4
000019C0  E14C                    1075      LSL.W       #8, D4
000019C2  E04C                    1076      LSR.W       #8, D4
000019C4  EC4C                    1077      LSR.W       #6, D4      *ISOLATE SIZE
000019C6  4EB9 00001DD8           1078      JSR         GET_SIZE_ADDI  *PRINT SIZE
000019CC  B83C 0003               1079      CMP.B       #3, D4      *EA SHIFT
000019D0  6700 003E               1080      BEQ         EA_SHIFT    *BRANCH TO EA SHIFT
000019D4  3806                    1081      MOVE.W      D6, D4
000019D6  E14C                    1082      LSL.W       #8, D4
000019D8  E54C                    1083      LSL.W       #2, D4
000019DA  E04C                    1084      LSR.W       #8, D4
000019DC  EE4C                    1085      LSR.W       #7, D4      *D4 = TYPE
000019DE                          1086      
000019DE  3A06                    1087      MOVE.W      D6, D5      *GETTING DATA
000019E0  E94D                    1088      LSL.W       #4, D5      *SHIFT LEFT 4; RIGHT 13
000019E2  E04D                    1089      LSR.W       #8, D5      *
000019E4  EA4D                    1090      LSR.W       #5, D5      *D5 = DATA / REGISTER
000019E6                          1091      
000019E6  4EB9 00001DF8           1092      JSR         TYPE_CHOOSER
000019EC  4EB9 00001EAA           1093      JSR         COMMA
000019F2  4EB9 00001F0C           1094      JSR         SPACE
000019F8  3A06                    1095      MOVE.W      D6, D5      *SHIFT LEFT 13; RIGHT 13
000019FA  E14D                    1096      LSL.W       #8, D5  
000019FC  EB4D                    1097      LSL.W       #5, D5      *
000019FE  E04D                    1098      LSR.W       #8, D5
00001A00  EA4D                    1099      LSR.W       #5, D5      * D5 = EA REGISTER
00001A02  4EB9 00001CBC           1100      JSR         DATA_0
00001A08                          1101      
00001A08  16BC 0000               1102      MOVE.B      #00, (A3)
00001A0C                          1103      
00001A0C  6000 F826               1104      BRA         VALID_OPCODE
00001A10                          1105  EA_SHIFT
00001A10  4EB9 00001F0C           1106      JSR         SPACE
00001A16  3806                    1107      MOVE.W      D6, D4      *
00001A18  E14C                    1108      LSL.W       #8, D4      *
00001A1A  E54C                    1109      LSL.W       #2, D4
00001A1C  E04C                    1110      LSR.W       #8, D4      *
00001A1E  EA4C                    1111      LSR.W       #5, D4      *D4 = EA MODE
00001A20                          1112      
00001A20  3A06                    1113      MOVE.W      D6, D5      *SHIFT LEFT 13; RIGHT 13
00001A22  E14D                    1114      LSL.W       #8, D5  
00001A24  EB4D                    1115      LSL.W       #5, D5      *
00001A26  E04D                    1116      LSR.W       #8, D5
00001A28  EA4D                    1117      LSR.W       #5, D5      * D5 = EA REGISTER
00001A2A                          1118      
00001A2A  4EB9 00001E3A           1119      JSR         MODE_CHOOSER    *IF A WORD OR LONG   
00001A30  4EB9 00001C0C           1120      JSR         ADD_ERROR_CHECK 
00001A36  41F9 00001C8C           1121      LEA         MODE_JUMP, A0   *LOAD MODE JUMP TABLE
00001A3C  C9FC 0006               1122      MULS        #6, D4          *GET JUMP
00001A40  4EB0 4000               1123      JSR         0(A0, D4)       *JUMP
00001A44  6000 0002               1124      BRA         DONE
00001A48                          1125  DONE
00001A48  16BC 0000               1126      MOVE.B      #00, (A3)
00001A4C                          1127      
00001A4C  6000 F7E6               1128      BRA         VALID_OPCODE
00001A50                          1129  
00001A50                          1130  EA_CMP          *0 INVALID
00001A50  3C00                    1131      MOVE.W      D0, D6
00001A52                          1132      
00001A52  3806                    1133      MOVE.W      D6, D4      *GETTING OPMODE AKA SIZE
00001A54  EF4C                    1134      LSL.W       #7, D4      * 
00001A56  EE4C                    1135      LSR.W       #7, D4      *
00001A58  EC4C                    1136      LSR.W       #6, D4      *D4 = OPMODE AKA SIZE
00001A5A  4EB9 00001DD8           1137      JSR         GET_SIZE_ADDI
00001A60  3806                    1138      MOVE.W      D6, D4      
00001A62  E14C                    1139      LSL.W       #8, D4      *LEFT 10; RIGHT 13
00001A64  E54C                    1140      LSL.W       #2, D4
00001A66  E04C                    1141      LSR.W       #8, D4      *
00001A68  EA4C                    1142      LSR.W       #5, D4      *D4 = EA MODE
00001A6A                          1143      
00001A6A  3A06                    1144      MOVE.W      D6, D5      *SHIFT LEFT 13; RIGHT 13
00001A6C  E14D                    1145      LSL.W       #8, D5  
00001A6E  EB4D                    1146      LSL.W       #5, D5      *
00001A70  E04D                    1147      LSR.W       #8, D5
00001A72  EA4D                    1148      LSR.W       #5, D5      * D5 = EA REGISTER
00001A74                          1149      
00001A74  4EB9 00001E3A           1150      JSR         MODE_CHOOSER    *IF A WORD OR LONG    
00001A7A  41F9 00001C8C           1151      LEA         MODE_JUMP, A0   *LOAD MODE JUMP TABLE
00001A80  C9FC 0006               1152      MULS        #6, D4          *GET JUMP
00001A84  4EB0 4000               1153      JSR         0(A0, D4)       *JUMP
00001A88  4EB9 00001EAA           1154      JSR         COMMA
00001A8E  4EB9 00001F0C           1155      JSR         SPACE
00001A94  3A06                    1156      MOVE.W      D6, D5      *LEFT 4; RIGHT 13
00001A96  E94D                    1157      LSL.W       #4, D5      *
00001A98  E04D                    1158      LSR.W       #8, D5      *
00001A9A  EA4D                    1159      LSR.W       #5, D5      *D5 DESTINATION REGISTER
00001A9C                          1160      
00001A9C  4EB9 00001CBC           1161      JSR         DATA_0
00001AA2  16BC 0000               1162      MOVE.B      #00, (A3)
00001AA6                          1163      
00001AA6  6000 F78C               1164      BRA         VALID_OPCODE
00001AAA                          1165  EA_BCC          *0 INVALID (I THINK)
00001AAA  3C00                    1166      MOVE.W      D0, D6
00001AAC                          1167      
00001AAC  3806                    1168      MOVE.W      D6, D4
00001AAE  E94C                    1169      LSL.W       #4, D4
00001AB0  E04C                    1170      LSR.W       #8, D4
00001AB2  E84C                    1171      LSR.W       #4, D4   *D4 = BINARY CONDITION CODE
00001AB4  4EB9 00001E08           1172      JSR         PRINT_BCC
00001ABA  4EB9 00001F0C           1173      JSR         SPACE
00001AC0  4EB9 00001E5E           1174      JSR         OUTPUT_HEX
00001AC6  16BC 0000               1175      MOVE.B      #00, (A3)
00001ACA                          1176      
00001ACA  6000 F768               1177      BRA         VALID_OPCODE
00001ACE                          1178  EA_JSR   *5 INVALID; DONE
00001ACE                          1179  
00001ACE  3C00                    1180      MOVE.W      D0, D6
00001AD0                          1181      
00001AD0  4EB9 00001F0C           1182      JSR         SPACE
00001AD6  3806                    1183      MOVE.W      D6, D4      *GETTING SOURCE MODE
00001AD8  E14C                    1184      LSL.W       #8, D4      *
00001ADA  E54C                    1185      LSL.W       #2, D4      *SHIFT 10 BITS LEFT; 13 RIGHT
00001ADC  E04C                    1186      LSR.W       #8, D4      *
00001ADE  EA4C                    1187      LSR.W       #5, D4      *D4 = SOURCE MODE
00001AE0                          1188      
00001AE0  3A06                    1189      MOVE.W      D6, D5      *GETTING SOURCE REGISTER
00001AE2  E14D                    1190      LSL.W       #8, D5      *
00001AE4  EB4D                    1191      LSL.W       #5, D5      *SHIFT LEFT 13; RIGHT 13
00001AE6  E04D                    1192      LSR.W       #8, D5      *
00001AE8  EA4D                    1193      LSR.W       #5, D5      *D5 = SOURCE REGISTER
00001AEA                          1194      
00001AEA  4EB9 00001E3A           1195      JSR         MODE_CHOOSER  *INCASE MODE IS $111
00001AF0  4EB9 00001C38           1196      JSR         LEA_ERROR_CHECK
00001AF6  41F9 00001C8C           1197      LEA         MODE_JUMP, A0 *LOAD MODE JUMP TABLE
00001AFC  C9FC 0006               1198      MULS        #6, D4        *GET JUMP
00001B00  4EB0 4000               1199      JSR         0(A0, D4)     *JUM
00001B04                          1200      
00001B04  16BC 0000               1201      MOVE.B      #00, (A3)
00001B08                          1202      
00001B08  6000 F72A               1203      BRA         VALID_OPCODE
00001B0C                          1204  EA_MOVEM
00001B0C                          1205  
00001B0C  3C00                    1206      MOVE.W      D0, D6
00001B0E  3806                    1207      MOVE.W      D6, D4
00001B10  EB4C                    1208      LSL.W       #5, D4
00001B12  E94C                    1209      LSL.W       #4, D4
00001B14  E04C                    1210      LSR.W       #8, D4
00001B16  EE4C                    1211      LSR.W       #7, D4
00001B18  4EB9 00001E22           1212      JSR         REG_SIZE
00001B1E  3E06                    1213      MOVE.W      D6, D7
00001B20  EB4F                    1214      LSL.W       #5, D7
00001B22  E04F                    1215      LSR.W       #8, D7
00001B24  EE4F                    1216      LSR.W       #7, D7
00001B26  BE3C 0000               1217      CMP.B       #0, D7
00001B2A  6700 003E               1218      BEQ         PRINT_LIST
00001B2E  BE7C 0000               1219  EAP CMP.W       #0, D7      *IF ITS A ZERO, THAT MEANS WE JUST JUMPED HERE 
00001B32  6700 00A2               1220      BEQ         COMMA_SPACE *FROM CHECK TYPE, ELSE MEANS ITS UNALTERED
00001B36  3806                    1221  EAS MOVE.W      D6, D4      
00001B38  E14C                    1222      LSL.W       #8, D4      *LEFT 10; RIGHT 13
00001B3A  E54C                    1223      LSL.W       #2, D4
00001B3C  E04C                    1224      LSR.W       #8, D4      *
00001B3E  EA4C                    1225      LSR.W       #5, D4      *D4 = EA MODE
00001B40                          1226      
00001B40  3A06                    1227      MOVE.W      D6, D5      *SHIFT LEFT 13; RIGHT 13
00001B42  E14D                    1228      LSL.W       #8, D5  
00001B44  EB4D                    1229      LSL.W       #5, D5      *
00001B46  E04D                    1230      LSR.W       #8, D5
00001B48  EA4D                    1231      LSR.W       #5, D5      * D5 = EA REGISTER
00001B4A                          1232      
00001B4A  4EB9 00001E3A           1233      JSR         MODE_CHOOSER    *IF A WORD OR LONG    
00001B50  41F9 00001C8C           1234      LEA         MODE_JUMP, A0   *LOAD MODE JUMP TABLE
00001B56  C9FC 0006               1235      MULS        #6, D4          *GET JUMP
00001B5A  4EB0 4000               1236      JSR         0(A0, D4)       *JUMP
00001B5E                          1237      
00001B5E  BE7C 0001               1238      CMP.W       #1, D7 *IF ONE THEN THIS WAS PRINTED FIRST
00001B62  6700 0006               1239      BEQ         PRINT_LIST
00001B66                          1240      
00001B66  6000 008E               1241      BRA         DONE_PRINTING
00001B6A                          1242  PRINT_LIST
00001B6A  BE3C 0001               1243      CMP.B       #1, D7 
00001B6E  6700 0076               1244      BEQ         COMMA_SPACE2
00001B72  2E0A                    1245  EA2 MOVE.L      A2, D7
00001B74  548A                    1246      ADD.L       #2, A2
00001B76  143C 0008               1247      MOVE.B      #$8, D2
00001B7A  4244                    1248      CLR         D4
00001B7C                          1249  FOR_LOOP    
00001B7C  B404                    1250      CMP.B       D4, D2
00001B7E  6700 001E               1251      BEQ         ADDRESS_REGISTERS
00001B82  E25F                    1252      ROR.W       #1, D7
00001B84  6000 0006               1253      BRA         PRINT_CURRENT
00001B88  5244                    1254  JFZ ADDQ        #1, D4
00001B8A  60F0                    1255      BRA         FOR_LOOP
00001B8C                          1256      
00001B8C                          1257  PRINT_CURRENT
00001B8C  64FA                    1258      BCC         JFZ
00001B8E  1A04                    1259      MOVE.B      D4, D5
00001B90  4EB9 00001CBC           1260      JSR         DATA_0
00001B96  4EB9 00001F34           1261      JSR         SLASH
00001B9C  60EA                    1262      BRA         JFZ
00001B9E                          1263      
00001B9E                          1264  ADDRESS_REGISTERS
00001B9E  4244                    1265      CLR         D4
00001BA0                          1266  FOR_2
00001BA0  B404                    1267      CMP.B       D4, D2
00001BA2  6700 001E               1268      BEQ         CHECK_TYPE
00001BA6  E25F                    1269      ROR.W       #1, D7
00001BA8  6000 0006               1270      BRA         EA_PRINT_ADDRESS
00001BAC  5244                    1271  JFF ADDQ        #1, D4
00001BAE  60F0                    1272      BRA         FOR_2
00001BB0                          1273      
00001BB0                          1274  EA_PRINT_ADDRESS
00001BB0  64FA                    1275      BCC         JFF
00001BB2  1A04                    1276      MOVE.B      D4, D5
00001BB4  4EB9 00001F34           1277      JSR         SLASH
00001BBA  4EB9 00001CCA           1278      JSR         ADDR_1
00001BC0  60EA                    1279      BRA         JFF  
00001BC2                          1280  CHECK_TYPE
00001BC2  3E06                    1281      MOVE.W      D6, D7
00001BC4  EB4F                    1282      LSL.W       #5, D7  
00001BC6  E04F                    1283      LSR.W       #8, D7
00001BC8  EE4F                    1284      LSR.W       #7, D7
00001BCA  BE3C 0000               1285      CMP.B       #0, D7   *IF TYPE IS 0 THE LIST HAS BEEN PRINTED FIRST  
00001BCE  6700 FF5E               1286      BEQ         EAP      *THEREFORE ITS TIME TO PRINT THE EAP
00001BD2  6600 0022               1287      BNE         DONE_PRINTING
00001BD6                          1288      
00001BD6                          1289  COMMA_SPACE
00001BD6  4EB9 00001EAA           1290      JSR         COMMA
00001BDC  4EB9 00001F0C           1291      JSR         SPACE
00001BE2  6000 FF52               1292      BRA         EAS
00001BE6                          1293      
00001BE6                          1294  COMMA_SPACE2
00001BE6  4EB9 00001EAA           1295      JSR         COMMA
00001BEC  4EB9 00001F0C           1296      JSR         SPACE
00001BF2  6000 FF7E               1297      BRA         EA2
00001BF6                          1298      
00001BF6                          1299  DONE_PRINTING
00001BF6  16BC 0000               1300      MOVE.B      #00, (A3)
00001BFA  6000 F638               1301      BRA         VALID_OPCODE
00001BFE                          1302  
00001BFE                          1303  
00001BFE                          1304  
00001BFE                          1305  
00001BFE                          1306  
00001BFE                          1307  
00001BFE                          1308  
00001BFE                          1309  
00001BFE                          1310  
00001BFE                          1311  
00001BFE                          1312  
00001BFE                          1313  
00001BFE                          1314  
00001BFE                          1315  
00001BFE                          1316  
00001BFE                          1317  
00001BFE                          1318  BYEBYE
00001BFE  FFFF FFFF               1319      SIMHALT
00001C02                          1320  
00001C02                          1321  
00001C02                          1322  
00001C02                          1323  
00001C02                          1324  
00001C02                          1325  
00001C02                          1326  
00001C02                          1327  
00001C02                          1328  
00001C02                          1329  
00001C02                          1330  
00001C02                          1331  
00001C02                          1332  
00001C02                          1333  
00001C02                          1334  
00001C02                          1335  MOVE_ERROR_CHECK       *only invalid move is desn addr reg
00001C02  B83C 0001               1336      CMP.B       #1, D4 *if d4 is one, dest is addr reg
00001C06  6700 0334               1337      BEQ         INVALID
00001C0A  4E75                    1338      RTS
00001C0C                          1339      
00001C0C                          1340  ADD_ERROR_CHECK  *COVERS ALL SHIFTS
00001C0C  B83C 0007               1341      CMP.B       #7, D4
00001C10  6700 0072               1342      BEQ         EAT_INVALID
00001C14  B83C 0001               1343      CMP.B       #1, D4
00001C18  6700 0322               1344      BEQ         INVALID
00001C1C  B83C 0000               1345      CMP.B       #0, D4
00001C20  6700 031A               1346      BEQ         INVALID
00001C24  4E75                    1347      RTS 
00001C26                          1348      
00001C26                          1349  ADDI_ERROR_CHECK *COVERS CLR
00001C26  B83C 0001               1350      CMP.B       #1, D4
00001C2A  6700 0310               1351      BEQ         INVALID
00001C2E  B83C 0007               1352      CMP.B       #7, D4
00001C32  6700 0050               1353      BEQ         EAT_INVALID
00001C36  4E75                    1354      RTS
00001C38                          1355      
00001C38                          1356  LEA_ERROR_CHECK *COVERS JSR
00001C38  B83C 0000               1357      CMP.B       #0, D4
00001C3C  6700 02FE               1358      BEQ         INVALID
00001C40  B83C 0001               1359      CMP.B       #1, D4
00001C44  6700 02F6               1360      BEQ         INVALID
00001C48  B83C 0003               1361      CMP.B       #3, D4
00001C4C  6700 02EE               1362      BEQ         INVALID
00001C50  B83C 0004               1363      CMP.B       #4, D4
00001C54  6700 02E6               1364      BEQ         INVALID
00001C58  B83C 0007               1365      CMP.B       #7, D4
00001C5C  6700 0026               1366      BEQ         EAT_INVALID
00001C60  4E75                    1367      RTS
00001C62                          1368      
00001C62                          1369  MOVEM_ERROR_CHECK *0, 1, 4, 7
00001C62  B83C 0000               1370      CMP.B       #0, D4
00001C66  6700 02D4               1371      BEQ         INVALID
00001C6A  B83C 0001               1372      CMP.B       #1, D4
00001C6E  6700 02CC               1373      BEQ         INVALID
00001C72  B83C 0004               1374      CMP.B       #4, D4
00001C76  6700 02C4               1375      BEQ         INVALID
00001C7A  B83C 0007               1376      CMP.B       #7, D4
00001C7E  6700 0004               1377      BEQ         EAT_INVALID
00001C82  4E75                    1378      RTS
00001C84                          1379      
00001C84                          1380      
00001C84                          1381      
00001C84                          1382      *assuming FOR NOW that it always eats a long
00001C84                          1383  EAT_INVALID *EATS THE NEXT TWO WORD VALUES... THEN CALLS INVALID
00001C84  548A                    1384      ADD.L       #2, A2      *EAT THE FIRST WORD
00001C86  548A                    1385      ADD.L       #2, A2      *EAT THE SECOND WORD
00001C88  6000 02B2               1386      BRA         INVALID
00001C8C                          1387  
00001C8C                          1388  
00001C8C                          1389  
00001C8C                          1390  
00001C8C                          1391  
00001C8C                          1392  
00001C8C                          1393  
00001C8C                          1394  
00001C8C                          1395  
00001C8C                          1396  
00001C8C                          1397  
00001C8C                          1398  
00001C8C                          1399  
00001C8C                          1400  
00001C8C                          1401  
00001C8C                          1402  
00001C8C                          1403  
00001C8C                          1404  
00001C8C  4EF9 00001CBC           1405  MODE_JUMP       JMP     DATA_0
00001C92  4EF9 00001CCA           1406                  JMP     ADDR_1
00001C98  4EF9 00001CD8           1407                  JMP     ADDI_2
00001C9E  4EF9 00001CEA           1408                  JMP     ADDP_3
00001CA4  4EF9 00001CF6           1409                  JMP     ADDM_4
00001CAA  4EF9 00001D02           1410                  JMP     ABSW_5
00001CB0  4EF9 00001D12           1411                  JMP     ABSL_6
00001CB6  4EF9 00001D2A           1412                  JMP     IMME_7
00001CBC                          1413  
00001CBC                          1414  DATA_0 *DONE
00001CBC  16F9 00001F62           1415      MOVE.B      M_DREG, (A3)+
00001CC2  4EB9 00001D68           1416      JSR         GET_REG
00001CC8  4E75                    1417      RTS
00001CCA                          1418  
00001CCA                          1419  ADDR_1 *ADD CONDITIONS FOR SOURCE ONLY, AND NEVER BYTES
00001CCA  16F9 00001F64           1420      MOVE.B      M_AREG, (A3)+
00001CD0  4EB9 00001D68           1421      JSR         GET_REG
00001CD6  4E75                    1422      RTS
00001CD8                          1423   
00001CD8                          1424  ADDI_2 *DONE
00001CD8  4EB9 00001EEC           1425      JSR         OPEN
00001CDE  4EB8 1CCA               1426      JSR         ADDR_1
00001CE2  4EB9 00001EF4           1427      JSR         CLOSE
00001CE8  4E75                    1428      RTS
00001CEA                          1429      
00001CEA                          1430  ADDP_3 *DONE
00001CEA  4EB8 1CD8               1431      JSR         ADDI_2
00001CEE  4EB9 00001EFC           1432      JSR         PLUS
00001CF4  4E75                    1433      RTS
00001CF6                          1434      
00001CF6                          1435  ADDM_4 *DONE
00001CF6  4EB9 00001F04           1436      JSR         SUB
00001CFC  4EB8 1CD8               1437      JSR         ADDI_2
00001D00  4E75                    1438      RTS
00001D02                          1439      
00001D02                          1440  ABSW_5  *DONE
00001D02  340A                    1441      MOVE.W      A2, D2
00001D04  4EB9 00001F14           1442      JSR         CASH
00001D0A  6100 0152               1443      BSR         OUTPUT_HEX
00001D0E  548A                    1444      ADD.L       #2, A2
00001D10  4E75                    1445      RTS
00001D12                          1446  
00001D12                          1447   
00001D12                          1448  ABSL_6 *
00001D12  4EB9 00001F14           1449      JSR         CASH
00001D18                          1450      
00001D18  340A                    1451      MOVE.W      A2, D2
00001D1A  6100 0142               1452      BSR         OUTPUT_HEX
00001D1E  548A                    1453      ADD.L       #2, A2      *ACQUIRED FIRST PART OF LONG
00001D20                          1454  
00001D20                          1455      
00001D20  340A                    1456      MOVE.W      A2, D2
00001D22  6100 013A               1457      BSR         OUTPUT_HEX
00001D26  548A                    1458      ADD.L       #2, A2
00001D28  4E75                    1459      RTS
00001D2A                          1460      
00001D2A                          1461  IMME_7  *FOR NOW ONLY WORKING WITH IMMEDIATE HEX VALUES
00001D2A  4EB9 00001EB2           1462      JSR         POUND
00001D30  4EB9 00001F14           1463      JSR         CASH
00001D36                          1464      
00001D36  340A                    1465      MOVE.W      A2, D2
00001D38  6100 0124               1466      BSR         OUTPUT_HEX
00001D3C  548A                    1467      ADD.L       #2, A2
00001D3E  340A                    1468      MOVE.W      A2, D2
00001D40  6100 011C               1469      BSR         OUTPUT_HEX
00001D44  548A                    1470      ADD.L       #2, A2
00001D46  4E75                    1471      RTS
00001D48                          1472  
00001D48                          1473  GET_SIZE
00001D48  4EB9 00001EBA           1474      JSR         DOT
00001D4E  B83C 0001               1475      CMP.B       #1, D4
00001D52  6700 017C               1476      BEQ         BYTE
00001D56  B83C 0003               1477      CMP.B       #3, D4
00001D5A  6700 0166               1478      BEQ         WORD
00001D5E  B83C 0002               1479      CMP.B       #2, D4
00001D62  6700 017A               1480      BEQ         LONG  
00001D66  4E75                    1481      RTS
00001D68                          1482      
00001D68                          1483  GET_REG ******************
00001D68  2205                    1484      MOVE.L      D5, D1 
00001D6A  16C1                    1485      MOVE.B      D1, (A3)+
00001D6C  4E75                    1486      RTS
00001D6E                          1487      
00001D6E                          1488  GET_OPMODE
00001D6E  4EB9 00001EBA           1489      JSR         DOT
00001D74  B83C 0003               1490      CMP.B       #3, D4
00001D78  6700 0148               1491      BEQ         WORD
00001D7C  B83C 0007               1492      CMP.B       #7, D4
00001D80  6700 015C               1493      BEQ         LONG
00001D84  4E75                    1494      RTS
00001D86                          1495      
00001D86                          1496  GET_OPMODE_MATH
00001D86  4EB9 00001EBA           1497      JSR         DOT
00001D8C  B83C 0000               1498      CMP.B       #0, D4
00001D90  6700 013E               1499      BEQ         BYTE
00001D94  B83C 0004               1500      CMP.B       #4, D4
00001D98  6700 0136               1501      BEQ         BYTE
00001D9C  B83C 0001               1502      CMP.B       #1, D4
00001DA0  6700 0120               1503      BEQ         WORD
00001DA4  B83C 0005               1504      CMP.B       #5, D4
00001DA8  6700 0118               1505      BEQ         WORD
00001DAC  B83C 0002               1506      CMP.B       #2, D4
00001DB0  6700 012C               1507      BEQ         LONG
00001DB4  B83C 0006               1508      CMP.B       #6, D4
00001DB8  6700 0124               1509      BEQ         LONG
00001DBC  4E75                    1510      RTS
00001DBE                          1511      
00001DBE                          1512  GET_DATA ******************
00001DBE  4EB9 00001EB2           1513      JSR         POUND
00001DC4  BA3C 0000               1514      CMP.B       #0, D5
00001DC8  6700 0008               1515      BEQ         PRINT_8
00001DCC  2205                    1516      MOVE.L      D5, D1
00001DCE  16C1                    1517      MOVE.B      D1, (A3)+
00001DD0  4E75                    1518      RTS
00001DD2                          1519      
00001DD2                          1520  PRINT_8 ********
00001DD2  7208                    1521      MOVE.L      #8, D1
00001DD4  16C1                    1522      MOVE.B      D1, (A3)+
00001DD6  4E75                    1523      RTS
00001DD8                          1524      
00001DD8                          1525  GET_SIZE_ADDI
00001DD8  4EB9 00001EBA           1526      JSR         DOT
00001DDE  B83C 0000               1527      CMP.B       #0, D4
00001DE2  6700 00EC               1528      BEQ         BYTE
00001DE6  B83C 0001               1529      CMP.B       #1, D4
00001DEA  6700 00D6               1530      BEQ         WORD
00001DEE  B83C 0002               1531      CMP.B       #2, D4
00001DF2  6700 00EA               1532      BEQ         LONG  
00001DF6  4E75                    1533      RTS
00001DF8                          1534      
00001DF8                          1535  TYPE_CHOOSER
00001DF8  B83C 0000               1536      CMP.B       #0, D4      *IF IMMEDIATE
00001DFC  67C0                    1537      BEQ         GET_DATA    *IF BRANCHED  ->  #1 IS NOW PRINTED
00001DFE  B83C 0001               1538      CMP.B       #1, D4      *IF A DATA REG
00001E02  6700 FEB8               1539      BEQ         DATA_0
00001E06  4E75                    1540      RTS
00001E08                          1541      
00001E08                          1542  PRINT_BCC
00001E08  B83C 0004               1543      CMP.B       #4, D4
00001E0C  6700 010E               1544      BEQ         CC
00001E10  B83C 000E               1545      CMP.B       #14, D4
00001E14  6700 010E               1546      BEQ         GT
00001E18  B83C 000F               1547      CMP.B       #15, D4
00001E1C  6700 010E               1548      BEQ         LE
00001E20  4E75                    1549      RTS
00001E22                          1550      
00001E22                          1551  REG_SIZE
00001E22  4EB9 00001EBA           1552      JSR         DOT
00001E28  B83C 0000               1553      CMP.B       #0, D4
00001E2C  6700 0094               1554      BEQ         WORD
00001E30  B83C 0001               1555      CMP.B       #1, D4
00001E34  6700 00A8               1556      BEQ         LONG
00001E38  4E75                    1557      RTS
00001E3A                          1558  MODE_CHOOSER
00001E3A  B83C 0007               1559      CMP.B       #7, D4
00001E3E  6700 0004               1560      BEQ         NEW_MODE
00001E42  4E75                    1561      RTS
00001E44                          1562      
00001E44                          1563  NEW_MODE
00001E44  BA3C 0000               1564      CMP.B       #0, D5 *CHECK REGISTER(D5), WORD ADDRESS?
00001E48  6700 0010               1565      BEQ         TO_FIVE *CHANGE MODE (D4) TO 5
00001E4C  BA3C 0001               1566      CMP.B       #1, D5 *CHECK REGISTER(D5), LONG ADDRESS?
00001E50  6700 0004               1567      BEQ         TO_SIX *CHANGE MODE(D4) TO 6
00001E54  4E75                    1568      RTS
00001E56                          1569      
00001E56                          1570  TO_SIX  
00001E56  5304                    1571      SUB.B      #1, D4
00001E58  4E75                    1572      RTS
00001E5A                          1573  
00001E5A                          1574  TO_FIVE
00001E5A  5504                    1575      SUB.B      #2, D4
00001E5C  4E75                    1576      RTS
00001E5E                          1577  
00001E5E                          1578  OUTPUT_HEX
00001E5E                          1579      *OUTPUT 1ST
00001E5E  3E02                    1580      MOVE.W      D2, D7              *D7 = <1010 1111 0101 0111>
00001E60  E04F                    1581      LSR.W       #8, D7              *D7 = <0000 0000 1010 1111>
00001E62  E84F                    1582      LSR.W       #4, D7              *D7 = <0000 0000 0000 1010>
00001E64  1207                    1583      MOVE.B      D7, D1
00001E66  6100 F404               1584      BSR         CONVERT_TO_ASCII    *convert value in D1, to ascii
00001E6A  6100 003C               1585      BSR         ADD_CHAR         *print the char in D1  
00001E6E                          1586      *OUTPUT 2ND
00001E6E  3E02                    1587      MOVE.W      D2, D7
00001E70  E94F                    1588      LSL.W       #4, D7              *SHIFT OUT FURTHEST RIGHT BIT
00001E72  E04F                    1589      LSR.W       #8, D7
00001E74  E84F                    1590      LSR.W       #4, D7  
00001E76  1207                    1591      MOVE.B      D7, D1
00001E78  6100 F3F2               1592      BSR         CONVERT_TO_ASCII
00001E7C  6100 002A               1593      BSR         ADD_CHAR
00001E80                          1594      *OUTPUT 3RD
00001E80  3E02                    1595      MOVE.W      D2, D7
00001E82  E14F                    1596      LSL.W       #8, D7
00001E84  E04F                    1597      LSR.W       #8, D7
00001E86  E84F                    1598      LSR.W       #4, D7
00001E88  1207                    1599      MOVE.B      D7, D1
00001E8A  6100 F3E0               1600      BSR         CONVERT_TO_ASCII
00001E8E  6100 0018               1601      BSR         ADD_CHAR
00001E92                          1602      *OUTPUT 4TH
00001E92  3E02                    1603      MOVE.W      D2, D7  *D7 = <1010 1111 0101 0111>
00001E94  E14F                    1604      LSL.W       #8, D7  *     <0101 0111 0000 0000>
00001E96  E94F                    1605      LSL.W       #4, D7  *     <0111 0000 0000 0000>
00001E98  E04F                    1606      LSR.W       #8, D7  *     <
00001E9A  E84F                    1607      LSR.W       #4, D7
00001E9C  1207                    1608      MOVE.B      D7, D1
00001E9E  6100 F3CC               1609      BSR         CONVERT_TO_ASCII
00001EA2  6100 0004               1610      BSR         ADD_CHAR
00001EA6  4E75                    1611      RTS
00001EA8                          1612                                     *continue converting            
00001EA8                          1613  ADD_CHAR ********
00001EA8  16C1                    1614      MOVE.B      D1, (A3)+
00001EAA                          1615  
00001EAA                          1616  COMMA
00001EAA  16F9 00001F4E           1617      MOVE.B      M_COMMA, (A3)+
00001EB0  4E75                    1618      RTS
00001EB2                          1619      
00001EB2                          1620  POUND
00001EB2  16F9 00001F50           1621      MOVE.B      M_POUND, (A3)+
00001EB8  4E75                    1622      RTS
00001EBA                          1623          
00001EBA                          1624  DOT
00001EBA  16F9 00001F52           1625      MOVE.B      M_DOT, (A3)+
00001EC0  4E75                    1626      RTS   
00001EC2                          1627  
00001EC2                          1628  WORD
00001EC2  16F9 00001F54           1629      MOVE.B      M_WORD, (A3)+
00001EC8  4EB9 00001F0C           1630      JSR         SPACE
00001ECE  4E75                    1631      RTS
00001ED0                          1632  
00001ED0                          1633  BYTE
00001ED0  16F9 00001F56           1634      MOVE.B      M_BYTE, (A3)+
00001ED6  4EB9 00001F0C           1635      JSR         SPACE
00001EDC  4E75                    1636      RTS
00001EDE                          1637      
00001EDE                          1638  LONG
00001EDE  16F9 00001F58           1639      MOVE.B      M_LONG, (A3)+
00001EE4  4EB9 00001F0C           1640      JSR         SPACE
00001EEA  4E75                    1641      RTS
00001EEC                          1642      
00001EEC                          1643  OPEN
00001EEC  16F9 00001F5A           1644      MOVE.B      M_OPEN, (A3)+
00001EF2  4E75                    1645      RTS
00001EF4                          1646  
00001EF4                          1647  CLOSE
00001EF4  16F9 00001F5C           1648      MOVE.B      M_CLOSE, (A3)+
00001EFA  4E75                    1649      RTS
00001EFC                          1650      
00001EFC                          1651  PLUS
00001EFC  16F9 00001F5E           1652      MOVE.B      M_PLUS, (A3)+
00001F02  4E75                    1653      RTS
00001F04                          1654      
00001F04                          1655  SUB
00001F04  16F9 00001F60           1656      MOVE.B      M_SUB, (A3)+
00001F0A  4E75                    1657      RTS
00001F0C                          1658      
00001F0C                          1659  SPACE
00001F0C  16F9 00002070           1660      MOVE.B      M_SPACE, (A3)+
00001F12  4E75                    1661      RTS    
00001F14                          1662      
00001F14                          1663  CASH
00001F14  16F9 00001F4C           1664      MOVE.B      M_CASH, (A3)+
00001F1A  4E75                    1665      RTS
00001F1C                          1666  
00001F1C                          1667  CC
00001F1C  16F9 00001F66           1668      MOVE.B      M_CC, (A3)+
00001F22  4E75                    1669      RTS
00001F24                          1670  GT
00001F24  16F9 00001F69           1671      MOVE.B      M_GT, (A3)+
00001F2A  4E75                    1672      RTS
00001F2C                          1673  
00001F2C                          1674  LE
00001F2C  16F9 00001F6C           1675      MOVE.B      M_LE, (A3)+
00001F32  4E75                    1676      RTS
00001F34                          1677      
00001F34                          1678  SLASH
00001F34  16F9 00001F6F           1679      MOVE.B      M_SLASH, (A3)+
00001F3A  4E75                    1680      RTS
00001F3C                          1681      
00001F3C                          1682  INVALID
00001F3C  16BC 0000               1683      MOVE.B      #00, (A3)
00001F40  6000 F274               1684      BRA         INVALID_OPCODE
00001F44                          1685      
00001F44                          1686  
00001F44  =0000000D               1687  CR      EQU     $0D
00001F44  =0000000A               1688  LF      EQU     $0A
00001F44                          1689  
00001F44= 49 4E 56 41 4C 49 ...   1690  M_INVAL DC.B 'INVALID',0
00001F4C= 24 00                   1691  M_CASH  DC.B '$',0
00001F4E= 2C 00                   1692  M_COMMA DC.B ',',0
00001F50= 23 00                   1693  M_POUND DC.B '#',0
00001F52= 2E 00                   1694  M_DOT   DC.B '.',0
00001F54= 57 00                   1695  M_WORD  DC.B 'W',0
00001F56= 42 00                   1696  M_BYTE  DC.B 'B',0
00001F58= 4C 00                   1697  M_LONG  DC.B 'L',0
00001F5A= 28 00                   1698  M_OPEN  DC.B '(',0
00001F5C= 29 00                   1699  M_CLOSE DC.B ')',0
00001F5E= 2B 00                   1700  M_PLUS  DC.B '+',0
00001F60= 2D 00                   1701  M_SUB   DC.B '-',0
00001F62= 44 00                   1702  M_DREG  DC.B 'D',0
00001F64= 41 00                   1703  M_AREG  DC.B 'A',0
00001F66= 43 43 00                1704  M_CC    DC.B 'CC',0
00001F69= 47 54 00                1705  M_GT    DC.B 'GT',0
00001F6C= 4C 45 00                1706  M_LE    DC.B 'LE',0
00001F6F= 2F 00                   1707  M_SLASH DC.B '/',0
00001F71                          1708  
00001F71                          1709  
00001F71                          1710  
00001F71                          1711  
00001F71                          1712  
00001F71                          1713  
00001F71                          1714  
00001F71                          1715  
00001F71                          1716  
00001F71                          1717  
00001F71                          1718  
00001F71                          1719  
00001F71                          1720  -------------------- end include --------------------
00001F71                          1721  
00001F72  FFFF FFFF               1722      SIMHALT             ; halt simulator
00001F76                          1723  
00001F76  =0000000D               1724  CR          EQU     $0D
00001F76  =0000000A               1725  LF          EQU     $0A
00001F76                          1726  
00001F76= 50 6C 65 61 73 65 ...   1727  M_INPUT_START DC.B 'Please enter starting memory address in hexadecimal:',CR,LF,0
00001FAD= 50 6C 65 61 73 65 ...   1728  M_INPUT_END   DC.B 'Please enter ending memory address in hexadecimal:',CR,LF,0
00001FE2= 49 6E 76 61 6C 69 ...   1729  M_INVALID     DC.B 'Invalid value. Please enter a valid value: ',CR,LF,0
00002010= 45 71 75 61 6C 20 ...   1730  M_EQUAL       DC.B 'Equal values. No memory read. Please enter new values',CR,LF,0
00002048= 44 41 54 41 20 20 ...   1731  M_DATA        DC.B 'DATA    ',0
00002051= 20 20 20 20 00          1732  M_TAB         DC.B '    ',0
00002056= 50 72 65 73 73 20 ...   1733  M_PRESS_CONT  DC.B 'Press any key to continue',0
00002070                          1734  
00002070  =00000500               1735  STRING_START    EQU     $0500
00002070  =00000400               1736  DATA_START      EQU     $0400
00002070                          1737  
00002070  =00000100               1738  MEM_START       EQU     $0100
00002070  =00000200               1739  MEM_END         EQU     $0200
00002070                          1740  
00002070= 20 00                   1741  M_SPACE       DC.B  ' ',0
00002072= 0D 0A 00                1742  M_NEW_LINE    DC.B  '',CR,LF,0
00002075                          1743  
00002075                          1744  STOP:
00002075                          1745      END    MAIN

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSL_6              1D12
ABSW_5              1D02
ADD                 15D4
ADDA                15D8
ADDI                1584
ADDI_2              1CD8
ADDI_ERROR_CHECK    1C26
ADDM_4              1CF6
ADDP_3              1CEA
ADDQ                15AE
ADDRESS_REGISTERS   1B9E
ADDR_1              1CCA
ADD_CHAR            1EA8
ADD_ERROR_CHECK     1C0C
ALPH_CHAR           127E
AND                 15D0
ASL                 15E5
ASR                 15E9
BCC                 15B3
BYEBYE              1BFE
BYTE                1ED0
CASH                1F14
CC                  1F1C
CHECK_TYPE          1BC2
CLOSE               1EF4
CMP                 15C7
COMMA               1EAA
COMMA_SPACE         1BD6
COMMA_SPACE2        1BE6
CONVERT_TO_ASCII    126C
CR                  D
DATA                12B4
DATA_0              1CBC
DATA_START          400
DIVU                15BB
DN_VERSION          171C
DONE                1A48
DONE_PRINTING       1BF6
DOT                 1EBA
EA2                 1B72
EAP                 1B2E
EAS                 1B36
EAT_INVALID         1C84
EA_ADD              16FC
EA_ADDA             1872
EA_ADDI             17B6
EA_ADDQ             1818
EA_BCC              1AAA
EA_CLR              1976
EA_CMP              1A50
EA_JSR              1ACE
EA_LEA              191E
EA_LSD              19BC
EA_MOVE             15F5
EA_MOVEA            166A
EA_MOVEM            1B0C
EA_MOVEQ            16C2
EA_MULS             18CC
EA_PRINT_ADDRESS    1BB0
EA_SHIFT            1A10
EA_VERSION          1766
EFFECTIVE_ADDRESSING  1190
END                 12C2
END_PRINT_DATA_LOOP  120E
EQUAL_ERROR         1140
FOR_2               1BA0
FOR_LOOP            1B7C
GET_DATA            1DBE
GET_NEXT_INPUT      1068
GET_OPMODE          1D6E
GET_OPMODE_MATH     1D86
GET_REG             1D68
GET_SIZE            1D48
GET_SIZE_ADDI       1DD8
GT                  1F24
IMME_7              1D2A
IM_NEW_LINE         128C
IM_SPACE            129A
INCREMENT_LINE      11AE
INPUT_END           103C
INPUT_START         100C
INVALID             1F3C
INVALID_CHAR_ERROR  10D4
INVALID_OPCODE      11B6
INVALID_OPCODE_CONT  11C4
JFF                 1BAC
JFZ                 1B88
LE                  1F2C
LEA_ERROR_CHECK     1C38
LF                  A
LONG                1EDE
LSL                 15DD
LSR                 15E1
MAIN                1000
MEM_END             200
MEM_START           100
MODE_CHOOSER        1E3A
MODE_JUMP           1C8C
MOVE                1589
MOVEA               158E
MOVEM               15A8
MOVEM_ERROR_CHECK   1C62
MOVEQ               15B5
MOVE_ERROR_CHECK    1C02
MULS                15CB
M_AREG              1F64
M_BYTE              1F56
M_CASH              1F4C
M_CC                1F66
M_CLOSE             1F5C
M_COMMA             1F4E
M_DATA              2048
M_DOT               1F52
M_DREG              1F62
M_EQUAL             2010
M_GT                1F69
M_INPUT_END         1FAD
M_INPUT_START       1F76
M_INVAL             1F44
M_INVALID           1FE2
M_LE                1F6C
M_LONG              1F58
M_NEW_LINE          2072
M_OPEN              1F5A
M_PLUS              1F5E
M_POUND             1F50
M_PRESS_CONT        2056
M_SLASH             1F6F
M_SPACE             2070
M_SUB               1F60
M_TAB               2051
M_WORD              1F54
NEW_MODE            1E44
NUMERIC_CHAR        1278
OP0000              133C
OP0001              1346
OP0010              1350
OP0011              1354
OP0100              1380
OP0101              1404
OP0110              140E
OP0111              1428
OP1000              1432
OP1001              145E
OP1011              1468
OP1100              1472
OP1101              149E
OP1110              14CA
OPCLR               1594
OPEN                1EEC
OPJSR               159C
OPLEA               1598
OPNOP               15A0
OPRTS               15A4
OPSUB               15C3
OP_JTAB             12DA
OR                  15C0
OUTPUT_CHAR         1284
OUTPUT_D1B          1218
OUTPUT_HEX          1E5E
PLUS                1EFC
POUND               1EB2
PRESS_TO_CONTINUE   1190
PRE_READ_MEMORY     116C
PRINT_8             1DD2
PRINT_ADDRESS       11E2
PRINT_ADDRESS_LOOP  11E6
PRINT_BCC           1E08
PRINT_CURRENT       1B8C
PRINT_DATA          11CA
PRINT_DATA_LOOP     11FA
PRINT_LIST          1B6A
PRINT_OPCODE        1256
PRINT_OPCODE_EA     1240
READ_CHAR           106A
READ_CHAR_LOOP      108C
READ_MEMORY         1122
READ_MEMORY_CONT    1186
READ_MEMORY_LOOP    116E
REG_SIZE            1E22
REMOVE_ZERO         1086
REMOVE_ZEROES       1074
RETURN_TO_SUBROUTINE  126A
ROL                 15ED
ROR                 15F1
SLASH               1F34
SPACE               1F0C
STOP                2075
STRING_START        500
SUB                 1F04
SWAP_VALUES         1150
TAB                 12A6
TEST                110E
TO_FIVE             1E5A
TO_SIX              1E56
TYPE_CHOOSER        1DF8
VALIDATE_START_END  112E
VALID_CHAR          10FE
VALID_LETTER_LC     10F6
VALID_LETTER_UC     10EE
VALID_NUMBER        10E6
VALID_OPCODE        1234
VERIFY_OPCODE       12C2
WORD                1EC2
_ADD                14B6
_ADDA               14C0
_AND                1494
_ASD                1524
_ASL                153E
_ASR                1548
_CLR                13C8
_DIVU               144A
_JSR                13DC
_LEA                13D2
_LSD                14F8
_LSL                1510
_LSR                151A
_MOVE               136C
_MOVEA              1376
_MOVEM              13FA
_MULS               148A
_NOP                13E6
_OR                 1454
_ROD                1552
_ROL                156C
_ROR                1576
_RTS                13F0
