00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/1/2016 6:19:57 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :
00000000                             3  * Written by :
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  MAIN:                  ; first instruction of program
00001000  6000 0006                  9      BRA             INPUT_START
00001004                            10      
00001004                            11      INCLUDE         'Main.X68'
00001004                            12  START:
00001004                            13      *TODO: CHANGE THIS VALUE TO RIGHT AFTER PROGRAM CODE
00001004  6000 0104                 14      BRA         TEST
00001008                            15      
00001008                            16  
00001008                            17  INPUT_START
00001008  6000 0100                 18      BRA         TEST
0000100C  43F9 00001292             19      LEA         M_INPUT_START,A1      *load message
00001012  103C 000E                 20      MOVE.B      #14,D0          *display string
00001016  4E4F                      21      TRAP        #15             *output string
00001018  227C 00000300             22      MOVE.L      #$0300,A1       *set address of register A1 for string
0000101E  103C 0002                 23      MOVE.B      #2,D0           *input string into A1 Trap
00001022  4E4F                      24      TRAP        #15             *input string from user
00001024  6100 0040                 25      BSR         READ_CHAR       *check for valid input
00001028  23C3 00000100             26      MOVE.L      D3,MEM_START    *put the starting address in memory
0000102E  B87C 0000                 27      CMP         #0,D4           *check the result register (D4)
00001032  6700 0004                 28      BEQ         INPUT_END       *valid value. read the ending value
00001036  60D0                      29      BRA         INPUT_START     *invalid value. try inputting start value again    
00001038                            30      
00001038                            31  INPUT_END
00001038  43F9 000012C9             32      LEA         M_INPUT_END,A1  *load message
0000103E  103C 000E                 33      MOVE.B      #14,D0          *display string
00001042  4E4F                      34      TRAP        #15             *output string
00001044  227C 00000300             35      MOVE.L      #$0300,A1       *set address of register A1 for string
0000104A  103C 0002                 36      MOVE.B      #2,D0           *input string into A1 Trap
0000104E  4E4F                      37      TRAP        #15             *input string from user
00001050  6100 0014                 38      BSR         READ_CHAR       *check for valid input
00001054  23C3 00000200             39      MOVE.L      D3,MEM_END      *put ending address into memory
0000105A  B87C 0000                 40      CMP         #0,D4           *check the result register (D4)
0000105E  6700 00BE                 41      BEQ         READ_MEMORY     *valid value. read the ending value
00001062  60D4                      42      BRA         INPUT_END       *invalid value. try inputting start value again    
00001064                            43      
00001064                            44  GET_NEXT_INPUT
00001064  4E75                      45      RTS
00001066                            46  
00001066                            47  READ_CHAR                       *verify that string is valid (all hexadecimal digits)
00001066  4243                      48      CLR         D3              *D3 will act as the total result
00001068  2849                      49      MOVE.L      A1,A4           *the stop address
0000106A  143C 0006                 50      MOVE.B      #6,D2           *put 6 in D2
0000106E  D8C2                      51      ADD.W       D2,A4           *A4 is now the stop address(A4)
00001070                            52      
00001070                            53  REMOVE_ZEROES
00001070  4281                      54      CLR.L       D1              *D1 will act as the temporary value
00001072  1211                      55      MOVE.B      (A1),D1         *read the byte from string
00001074  143C 0030                 56      MOVE.B      #$30,D2         *put ascii zero in D2
00001078  B202                      57      CMP.B       D2,D1           *compare ascii zero and value of D1
0000107A  6700 0006                 58      BEQ         REMOVE_ZERO     *skip over that character   
0000107E  6000 0008                 59      BRA         READ_CHAR_LOOP  *begin converting characters to numerical values
00001082                            60  REMOVE_ZERO
00001082  5289                      61      ADD.L       #1,A1           *increment string start address
00001084  528C                      62      ADD.L       #1,A4           *increment string end address
00001086  60E8                      63      BRA         REMOVE_ZEROES   *loop back and keep removing zeroes
00001088                            64  READ_CHAR_LOOP     
00001088  4281                      65      CLR.L       D1              *D1 will act as the temporary value
0000108A  1211                      66      MOVE.B      (A1),D1         *read the byte from string
0000108C  B27C 0000                 67      CMP         #0,D1           *compare 00 (NULL) and the byte ascii value in D1
00001090  67D2                      68      BEQ         GET_NEXT_INPUT    *if you reached the end of the string, end loop
00001092                            69      
00001092  143C 0030                 70      MOVE.B      #$30,D2         *put ascii zero in D2
00001096  B202                      71      CMP.B       D2,D1           *compare ascii zero and value of D1
00001098  6D00 0036                 72      BLT         INVALID_CHAR_ERROR *branch on invalid (too small) ascii value   
0000109C  143C 0066                 73      MOVE.B      #$66,D2         *put ascii f in D2
000010A0  B202                      74      CMP.B       D2,D1           *compare ascii f and value of D1
000010A2  6E2C                      75      BGT.B       INVALID_CHAR_ERROR *branch on invalid ascii value
000010A4  143C 0061                 76      MOVE.B      #$61,D2         *put ascii a in D2
000010A8  B202                      77      CMP.B       D2,D1           *compare ascii a and value of D1
000010AA  6C00 0046                 78      BGE         VALID_LETTER_LC *value is between a and f. Loop back.
000010AE                            79      
000010AE  143C 0039                 80      MOVE.B      #$39,D2         *put ascii 9 in D2
000010B2  B202                      81      CMP.B       D2,D1           *compare ascii 9 and value of D1
000010B4  6F00 002C                 82      BLE         VALID_NUMBER    *value between 0 and 9. Loop back.
000010B8                            83  
000010B8  143C 0041                 84      MOVE.B      #$41,D2         *put ascii A into D2
000010BC  B202                      85      CMP.B       D2,D1           *compare ascii A and value of D1
000010BE  6D00 0010                 86      BLT         INVALID_CHAR_ERROR    *value between 9 and A (Invalid)
000010C2                            87      
000010C2  143C 0046                 88      MOVE.B      #$46,D2         *put ascii F into D2
000010C6  B202                      89      CMP.B       D2,D1           *compare ascii F and value of D1
000010C8  6E00 0006                 90      BGT         INVALID_CHAR_ERROR    *value between F and a (Invalid)
000010CC                            91           
000010CC  6000 001C                 92      BRA         VALID_LETTER_UC *value is between A and F        
000010D0                            93  INVALID_CHAR_ERROR   
000010D0  43F9 000012FE             94      LEA         M_INVALID,A1    *load error message
000010D6  103C 000E                 95      MOVE.B      #14,D0          *display string trap
000010DA  4E4F                      96      TRAP        #15             *output error message
000010DC  183C 0001                 97      MOVE.B      #1,D4           *put invalid output in result register
000010E0  4E75                      98      RTS
000010E2                            99  VALID_NUMBER
000010E2  0401 0030                100      SUB.B       #$30,D1         *get actual value from ascii value
000010E6  6000 0012                101      BRA         VALID_CHAR      *read the next char in string
000010EA                           102  VALID_LETTER_UC
000010EA  0401 0037                103      SUB.B       #$37,D1         *get actual value from ascii value
000010EE  6000 000A                104      BRA         VALID_CHAR      *read the next char in string    
000010F2                           105  VALID_LETTER_LC
000010F2  0401 0057                106      SUB.B       #$57,D1         *get actual value from ascii value
000010F6  6000 0002                107      BRA         VALID_CHAR      *read the next char in string   
000010FA                           108  VALID_CHAR
000010FA  183C 0000                109      MOVE.B      #0,D4           *return valid value entry in D4    
000010FE  E98B                     110      LSL.L       #4,D3           *put hex digit in proper place
00001100  D681                     111      ADD.L       D1,D3           *put new total in D3
00001102  5289                     112      ADD.L       #1,A1           *increment address
00001104  B8C9                     113      CMP         A1,A4           *if A1 > A4
00001106  6E80                     114      BGT         READ_CHAR_LOOP  *begin converting to float    
00001108  4E75                     115      RTS                         *loop back to INPUT_START || INPUT_END   
0000110A                           116     
0000110A                           117  TEST
0000110A  23FC 00001000 00000100   118      MOVE.L      #$1000,MEM_START
00001114  23FC 00001300 00000200   119      MOVE.L      #$1300,MEM_END
0000111E                           120  READ_MEMORY   
0000111E  2479 00000100            121      MOVEA.L     MEM_START,A2    *A2 will be the starting/current address
00001124  2679 00000200            122      MOVEA.L     MEM_END,A3      *A3 will act as the ending address
0000112A                           123      
0000112A                           124  VALIDATE_START_END
0000112A  220A                     125      MOVE.L      A2,D1           *copy start address into D1
0000112C  240B                     126      MOVE.L      A3,D2           *copy end address into D2
0000112E  B441                     127      CMP         D1,D2           *compare start and end values
00001130  6700 000A                128      BEQ         EQUAL_ERROR     *Start address is equal to end address
00001134  6D00 0016                129      BLT         SWAP_VALUES     *Start address is larger than end address
00001138  6000 002E                130      BRA         PRE_READ_MEMORY *begin reading memory
0000113C                           131      
0000113C                           132  EQUAL_ERROR
0000113C  43F9 0000132C            133      LEA         M_EQUAL,A1      *load error message
00001142  103C 000E                134      MOVE.B      #14,D0          *display string trap
00001146  4E4F                     135      TRAP        #15             *output error message
00001148  6000 FEBE                136      BRA         INPUT_START     *restart program (request ui again)
0000114C                           137      
0000114C                           138  SWAP_VALUES
0000114C  2239 00000100            139      MOVE.L      MEM_START,D1    *put starting address in D1
00001152  2439 00000200            140      MOVE.L      MEM_END,D2      *put ending address in D2
00001158  23C2 00000100            141      MOVE.L      D2,MEM_START    *swap the two values in memory
0000115E  23C1 00000200            142      MOVE.L      D1,MEM_END
00001164  2442                     143      MOVEA.L     D2,A2           *A2 will be the starting/current address
00001166  2641                     144      MOVEA.L     D1,A3           *A3 will act as the ending address
00001168                           145  PRE_READ_MEMORY
00001168  2C4A                     146      MOVE.L      A2,A6           *A6 will act as the current address for Data               
0000116A                           147  READ_MEMORY_LOOP
0000116A  2679 00000200            148      MOVE.L      MEM_END,A3        *put ending address in A3
00001170  B6CA                     149      CMP         A2,A3             *compare the incrementing address and the end address
00001172  6700 011A                150      BEQ         END               *stop if the end address is reached
00001176                           151      
00001176  E05E                     152      ROR         #8,D6               *select correct byte
00001178  BC3C 003C                153      CMP.B       #60,D6              *see if maximum lines printed
0000117C  6C00 000E                154      BGE         PRESS_TO_CONTINUE
00001180  E15E                     155      ROL         #8,D6
00001182                           156  
00001182                           157      
00001182                           158  READ_MEMORY_CONT                    *continue reading memory (if branched)  
00001182  101A                     159      MOVE.B      (A2)+,D0          *get the value from incrementing address 
00001184  E148                     160      LSL.W       #8,D0             *make room for the next byte of A2
00001186  1022                     161      MOVE.B      -(A2),D0          *copy the rest of A2 to D0    
Line 162 ERROR: Undefined symbol
00001188  6000 AA04                162      BRA         VERIFY_OPCODE
0000118C                           163      
0000118C                           164      
0000118C                           165          
0000118C                           166  
0000118C                           167  EFFECTIVE_ADDRESSING
0000118C                           168  
0000118C                           169      
0000118C                           170  PRESS_TO_CONTINUE
0000118C  1C3C 0000                171      MOVE.B      #00,D6              *reset counter
00001190  E19E                     172      ROL.L       #8,D6               *put byte back in place
00001192  43F9 00001372            173      LEA         M_PRESS_CONT,A1     *load press key to continue messageu
00001198  103C 000E                174      MOVE.B      #14,D0              *load into D0
0000119C  4E4F                     175      TRAP        #15                 *display message
0000119E  103C 0005                176      MOVE.B      #5,D0               *read single character from keyboard
000011A2  4E4F                     177      TRAP        #15    
000011A4  6100 00B2                178      BSR         IM_NEW_LINE            *add new line
000011A8  60D8                     179      BRA         READ_MEMORY_CONT    *continue reading loop
000011AA                           180      
000011AA                           181  INCREMENT_LINE
000011AA  E09E                     182      ROR.L       #8,D6               *select correct byte
000011AC  5206                     183      ADD.B       #1,D6               *increment counter
000011AE  E19E                     184      ROL.L       #8,D6               *put byte back in place
000011B0  4E75                     185      RTS 
000011B2                           186      
000011B2                           187  INVALID_OPCODE
000011B2  BC3C 0008                188      CMP.B       #8,D6               *check the loop increment counter
000011B6  6D00 0006                189      BLT         INVALID_OPCODE_CONT *less than long length. continue       
000011BA  6100 0008                190      BSR         PRINT_DATA          *long amount of data. print it.
000011BE                           191  INVALID_OPCODE_CONT  
000011BE  528A                     192      ADD.L       #1,A2               *increment current address  
000011C0  5206                     193      ADD.B       #1,D6               *increment counter
000011C2  60A6                     194      BRA         READ_MEMORY_LOOP    *data cap not reached. read next byte.    
000011C4                           195      
000011C4                           196  PRINT_DATA
000011C4  BC7C 0000                197      CMP         #00,D6              *compare 00 and the increment counter
000011C8  6E00 006C                198      BGT         RETURN_TO_SUBROUTINE    *no unreadable data. RTS
000011CC                           199      *otherwise print out the data
000011CC  1C3C 0000                200      MOVE.B      #00,D6              *reset the increment counter
000011D0  6100 0012                201      BSR         PRINT_ADDRESS       *print the data address
000011D4  6100 009C                202      BSR         TAB                 *insert a space
000011D8  6100 00A6                203      BSR         DATA                *print 'DATA'   
000011DC  61CC                     204      BSR         INCREMENT_LINE      *increment line counter (line was printed)
000011DE  6100 001C                205      BSR         PRINT_DATA_LOOP     *print the data
000011E2  4E75                     206      RTS
000011E4                           207  PRINT_ADDRESS
000011E4  280E                     208      MOVE.L      A6,D4               *put the address in D4
000011E6  4243                     209      CLR         D3                  *counter for long
000011E8                           210      
000011E8                           211  PRINT_ADDRESS_LOOP
000011E8  B67C 0004                212      CMP         #4,D3               *if long reached
000011EC  6C00 0048                213      BGE         RETURN_TO_SUBROUTINE *exit loop
000011F0  E19C                     214      ROL.L       #8,D4               *put ending byte at beginning
000011F2  1204                     215      MOVE.B      D4,D1               *put byte in D1 for printing
000011F4  6100 0024                216      BSR         OUTPUT_D1B          *print the first byte of D1
000011F8  5203                     217      ADD.B       #1,D3               *increment D3 (loop counter)
000011FA  60EC                     218      BRA         PRINT_ADDRESS_LOOP  *repeat loop         
000011FC                           219           
000011FC                           220  PRINT_DATA_LOOP
000011FC  121E                     221      MOVE.B      (A6)+,D1            *get the data
000011FE  1401                     222      MOVE.B      D1,D2               *copy the data to D2
00001200  BDCA                     223      CMP.L       A2,A6               *if current address reached
00001202  6E00 000C                224      BGT         END_PRINT_DATA_LOOP *continue reading addresses 
00001206                           225                                      *otherwise keep printing the data
00001206  6100 0012                226      BSR         OUTPUT_D1B          *print byte in D1 in hex
0000120A                           227      *---print a space----*
0000120A  6100 005A                228      BSR         IM_SPACE               *print a space                                
0000120E  60EC                     229      BRA         PRINT_DATA_LOOP     *repeat loop
00001210                           230  
00001210                           231  END_PRINT_DATA_LOOP
00001210  2C4A                     232      MOVE.L      A2,A6               *set new address for data/opcode
00001212  6100 0044                233      BSR         IM_NEW_LINE            *end line
00001216  6192                     234      BSR         INCREMENT_LINE      *increment line printing counter
00001218  4E75                     235      RTS                             *repeat loop   
0000121A                           236   
0000121A                           237  OUTPUT_D1B
0000121A                           238      *print the left character
0000121A  1401                     239      MOVE.B      D1,D2               *copy D1 to D2
0000121C  E809                     240      LSR.B       #4,D1               *get rid of right nibble  
0000121E  6100 0018                241      BSR         CONVERT_TO_ASCII    *convert value in D1, to ascii
00001222  6100 002C                242      BSR         OUTPUT_CHAR         *print the char in D1
00001226                           243      *print the right character
00001226  E90A                     244      LSL.B       #4,D2               *get rid of left nibble
00001228  E80A                     245      LSR.B       #4,D2               *put right nibble in place
0000122A  1202                     246      MOVE.B      D2,D1               *put right nibble in D1
0000122C  6100 000A                247      BSR         CONVERT_TO_ASCII    *convert value in D1, to ascii
00001230  6100 001E                248      BSR         OUTPUT_CHAR         *print the char in D1
00001234  4E75                     249      RTS
00001236                           250  VALID_OPCODE 
00001236                           251      
00001236                           252      
00001236                           253  RETURN_TO_SUBROUTINE
00001236  4E75                     254      RTS
00001238                           255    
00001238                           256  CONVERT_TO_ASCII
00001238  B23C 0009                257      CMP.B       #9,D1           *compare value with 9
0000123C  6E00 000C                258      BGT         ALPH_CHAR       *convert to numeric ascii
00001240  6000 0002                259      BRA         NUMERIC_CHAR    *convert to alphabetical ascii
00001244                           260  NUMERIC_CHAR        
00001244  0601 0030                261      ADD.B       #48,D1          *convert to ascii value
00001248  4E75                     262      RTS                         *continue converting
0000124A                           263  ALPH_CHAR
0000124A  0601 0037                264      ADD.B       #55,D1          *convert to ascii value
0000124E  4E75                     265      RTS                         *continue converting            
00001250                           266  OUTPUT_CHAR
00001250  103C 0006                267      MOVE.B      #6,D0           *output whatever's in D1
00001254  4E4F                     268      TRAP        #15
00001256  4E75                     269      RTS
00001258                           270  
00001258                           271  
00001258                           272  IM_NEW_LINE
00001258  43F9 0000138C            273      LEA         M_SPACE,A1      *load new line
0000125E  103C 000E                274      MOVE.B      #14,D0          *load message
00001262  4E4F                     275      TRAP        #15             *display message
00001264  4E75                     276      RTS
00001266                           277  IM_SPACE
00001266  123C 0020                278      MOVE.B      #32,D1
0000126A  103C 0006                279      MOVE.B      #6,D0
0000126E  4E4F                     280      TRAP        #15
00001270  4E75                     281      RTS
00001272                           282  TAB
00001272  43F9 0000136D            283      LEA         M_TAB,A1
00001278  103C 000E                284      MOVE.B      #14,D0
0000127C  4E4F                     285      TRAP        #15
0000127E  4E75                     286      RTS
00001280                           287  DATA
00001280  43F9 00001364            288      LEA         M_DATA,A1
00001286  103C 000E                289      MOVE.B      #14,D0
0000128A  4E4F                     290      TRAP        #15
0000128C  4E75                     291      RTS
0000128E                           292      
0000128E                           293  END
0000128E                           294  
0000128E  FFFF FFFF                295      SIMHALT             ; halt simulator
00001292                           296  
00001292  =0000000D                297  CR          EQU     $0D
00001292  =0000000A                298  LF          EQU     $0A
00001292                           299  
00001292= 50 6C 65 61 73 65 ...    300  M_INPUT_START DC.B 'Please enter starting memory address in hexadecimal:',CR,LF,0
000012C9= 50 6C 65 61 73 65 ...    301  M_INPUT_END   DC.B 'Please enter ending memory address in hexadecimal:',CR,LF,0
000012FE= 49 6E 76 61 6C 69 ...    302  M_INVALID     DC.B 'Invalid value. Please enter a valid value: ',CR,LF,0
0000132C= 45 71 75 61 6C 20 ...    303  M_EQUAL       DC.B 'Equal values. No memory read. Please enter new values',CR,LF,0
00001364= 44 41 54 41 20 20 ...    304  M_DATA        DC.B 'DATA    ',0
0000136D= 20 20 20 20 00           305  M_TAB         DC.B '    ',0
00001372= 50 72 65 73 73 20 ...    306  M_PRESS_CONT  DC.B 'Press any key to continue',0
0000138C                           307  
0000138C  =00000500                308  STRING_START    EQU     $0500
0000138C  =00000400                309  DATA_START      EQU     $0400
0000138C                           310  
0000138C  =00000100                311  MEM_START       EQU     $0100
0000138C  =00000200                312  MEM_END         EQU     $0200
0000138C                           313  
0000138C= 20 00                    314  M_SPACE       DC.B  ' ',0
0000138E                           315  
0000138E                           316      END     START
0000138E                           317  -------------------- end include --------------------

1 error detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ALPH_CHAR           124A
CONVERT_TO_ASCII    1238
CR                  D
DATA                1280
DATA_START          400
EFFECTIVE_ADDRESSING  118C
END                 128E
END_PRINT_DATA_LOOP  1210
EQUAL_ERROR         113C
GET_NEXT_INPUT      1064
IM_NEW_LINE         1258
IM_SPACE            1266
INCREMENT_LINE      11AA
INPUT_END           1038
INPUT_START         1008
INVALID_CHAR_ERROR  10D0
INVALID_OPCODE      11B2
INVALID_OPCODE_CONT  11BE
LF                  A
MAIN                1000
MEM_END             200
MEM_START           100
M_DATA              1364
M_EQUAL             132C
M_INPUT_END         12C9
M_INPUT_START       1292
M_INVALID           12FE
M_PRESS_CONT        1372
M_SPACE             138C
M_TAB               136D
NUMERIC_CHAR        1244
OUTPUT_CHAR         1250
OUTPUT_D1B          121A
PRESS_TO_CONTINUE   118C
PRE_READ_MEMORY     1168
PRINT_ADDRESS       11E4
PRINT_ADDRESS_LOOP  11E8
PRINT_DATA          11C4
PRINT_DATA_LOOP     11FC
READ_CHAR           1066
READ_CHAR_LOOP      1088
READ_MEMORY         111E
READ_MEMORY_CONT    1182
READ_MEMORY_LOOP    116A
REMOVE_ZERO         1082
REMOVE_ZEROES       1070
RETURN_TO_SUBROUTINE  1236
START               1004
STRING_START        500
SWAP_VALUES         114C
TAB                 1272
TEST                110A
VALIDATE_START_END  112A
VALID_CHAR          10FA
VALID_LETTER_LC     10F2
VALID_LETTER_UC     10EA
VALID_NUMBER        10E2
VALID_OPCODE        1236
